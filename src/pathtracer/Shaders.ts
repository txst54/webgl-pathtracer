// Auto-generated by glsl-parser.js


export const initialPassFSText = 
`#version 300 es
precision highp float;

uniform vec3 uEye;
uniform float uTime;
in vec3 initialRay;
uniform vec2 uRes;

uniform sampler2D temporalReservoirTexture;
uniform sampler2D motionVectorTexture;

layout(location = 0) out vec4 out_ReservoirData1;
layout(location = 1) out vec4 out_ReservoirData2;
layout(location = 2) out vec4 out_ReservoirData3;vec3 roomCubeMin = vec3(-10.0, -10.0, -10.0);
vec3 roomCubeMax = vec3(10.0, 10.0, 10.0);
vec3 sphereCenter = vec3(0.0, 0.0, 0.0);
float sphereRadius = 1.0;
vec3 light = vec3(0.0, 5.0, 0.0);
float lightIntensity = 1.0;
float infinity = 10000.0;
float epsilon = 0.0001;
float lightSize = 1.0;
float pi = 3.14159265359;
float maxBounces = 100.0;vec2 intersectCube(vec3 origin, vec3 ray, vec3 cubeMin, vec3 cubeMax) {
    vec3 tMin = (cubeMin - origin) / ray;
    vec3 tMax = (cubeMax - origin) / ray;
    vec3 t1 = min(tMin, tMax);
    vec3 t2 = max(tMin, tMax);
    float tNear = max(max(t1.x, t1.y), t1.z);
    float tFar = min(min(t2.x, t2.y), t2.z);
    return vec2(tNear, tFar);
}

vec3 normalForCube(vec3 hit, vec3 cubeMin, vec3 cubeMax) {
    if (hit.x < cubeMin.x + epsilon)
    return vec3(-1.0, 0.0, 0.0);
    else if (hit.x > cubeMax.x - epsilon)
    return vec3(1.0, 0.0, 0.0);
    else if (hit.y < cubeMin.y + epsilon)
    return vec3(0.0, -1.0, 0.0);
    else if (hit.y > cubeMax.y - epsilon)
    return vec3(0.0, 1.0, 0.0);
    else if (hit.z < cubeMin.z + epsilon)
    return vec3(0.0, 0.0, -1.0);
    else
    return vec3(0.0, 0.0, 1.0);
}float intersectSphere(vec3 origin, vec3 ray, vec3 sphereCenter, float sphereRadius) {
    vec3 toSphere = origin - sphereCenter;
    float a = dot(ray, ray);
    float b = 2.0 * dot(toSphere, ray);
    float c = dot(toSphere, toSphere) - sphereRadius*sphereRadius;
    float discriminant = b*b - 4.0*a*c;
    if(discriminant > 0.0) {
        float t = (-b - sqrt(discriminant)) / (2.0 * a);
        if(t > 0.0) return t;
    }
    return infinity;
}

vec3 normalForSphere(vec3 hit, vec3 sphereCenter, float sphereRadius) {
    return (hit - sphereCenter) / sphereRadius;
}struct Isect {
    float t; // Distance along the ray
    vec3 position;
    vec3 normal;
    vec3 albedo; // Simplified material color
    bool isLight; // Is the hit surface a light source?
    // vec3 emission; // Light emission color
    float pdf; // PDF of sampling this hit (e.g., light sampling PDF)
};

Isect intersect(vec3 ray, vec3 origin) {
    Isect isect;
    vec2 tRoom = intersectCube(origin, ray, roomCubeMin, roomCubeMax);
    float tSphere = intersectSphere(origin, ray, sphereCenter, sphereRadius);
    float tLight = intersectSphere(origin, ray, light, lightSize);
    float t = infinity;
    if (tRoom.x < tRoom.y) t = tRoom.y;
    if (tSphere < t) t = tSphere;
    if (tLight < t) t = tLight;

    isect.t = t;
    isect.albedo = vec3(0.75);
    isect.position = origin + ray * t;
    // float specularHighlight = 0.0;

    if (t == infinity) {
        return isect;
    }

    if (t == tRoom.y) {
        isect.normal = -normalForCube(isect.position, roomCubeMin, roomCubeMax);
        if(isect.position.x < -9.9999) isect.albedo = vec3(0.1, 0.5, 1.0);
        else if(isect.position.x > 9.9999) isect.albedo = vec3(1.0, 0.9, 0.1);
    } else if (t == tSphere) {
        isect.normal = normalForSphere(isect.position, sphereCenter, sphereRadius);
    } else if (t == tLight) {
        isect.normal = normalForSphere(isect.position, light, lightSize);
        isect.isLight = true;
    }
    return isect;
}float random(vec3 scale, float seed) {
    return fract(sin(dot(gl_FragCoord.xyz + seed, scale)) * 43758.5453 + seed);
}

vec3 uniformlyRandomDirection(float seed) {
    float u = random(vec3(12.9898, 78.233, 151.7182), seed);
    float v = random(vec3(63.7264, 10.873, 623.6736), seed);
    float z = 1.0 - 2.0 * u;
    float r = sqrt(1.0 - z * z);
    float angle = 6.283185307179586 * v;
    return vec3(r * cos(angle), r * sin(angle), z);
}

vec3 uniformlyRandomVector(float seed) {
    return uniformlyRandomDirection(seed) * sqrt(random(vec3(36.7539, 50.3658, 306.2759), seed));
}vec3 cosineWeightedDirection(float seed, vec3 normal) {
    // Simple cosine-weighted random direction
    float u = random(vec3(12.9898, 78.233, 151.7182), seed);
    float v = random(vec3(63.7264, 10.873, 623.6736), seed);
    float r = sqrt(u);
    float angle = 6.28318530718 * v;
    vec3 sdir, tdir;
    if (abs(normal.x) < .5) {
        sdir = cross(normal, vec3(1,0,0));
    } else {
        sdir = cross(normal, vec3(0,1,0));
    }
    tdir = cross(normal, sdir);
    return normalize(r*cos(angle)*sdir + r*sin(angle)*tdir + sqrt(1.-u)*normal);
}

float pdfCosineWeighted(vec3 direction, vec3 normal) {
    float cosTheta = dot(direction, normal);
    if (cosTheta <= 0.0) return 0.0;
    return cosTheta / pi;
}

float shadow(vec3 origin, vec3 ray, vec3 sphereCenter, float sphereRadius) {
    float t = intersectSphere(origin, ray, sphereCenter, sphereRadius);
    if (t < 1.0) return 0.0;
    return 1.0;
}
struct RCVertex {
    float w;
    vec3 L;
    // todo add triangle Id, barycentric tuple, lobe indices
};

struct Sample_Y {
    RCVertex rc_vertex;
    float epsilon_1;
    float epsilon_2;
    int k;
    float J;
};

struct Reservoir {
    Sample_Y Y;
    float W_Y;
    float w_sum;
    float c;
    float t;
};

Reservoir initializeReservoir() {
    Reservoir r;
    r.Y.rc_vertex.w = 0.0;
    r.Y.rc_vertex.L = vec3(0.0);
    r.Y.epsilon_1 = 0.0;
    r.Y.epsilon_2 = 0.0;
    r.Y.k = 0;
    r.Y.J = 0.0;
    r.W_Y = 0.0;
    r.w_sum = 0.0;
    r.c = 0.0;
    return r;
}

Reservoir unpackReservoir(vec4 uReservoirData1Vec, vec4 uReservoirData2Vec, vec4 uReservoirData3Vec) {
    Reservoir r;
    r.Y.rc_vertex.w = uReservoirData1Vec.r;
    r.Y.rc_vertex.L = uReservoirData1Vec.gba;
    r.Y.epsilon_1 = uReservoirData2Vec.r;
    r.Y.epsilon_2 = uReservoirData2Vec.g;
    r.Y.k = int(uReservoirData2Vec.b);
    r.Y.J = uReservoirData2Vec.a;
    r.W_Y = uReservoirData3Vec.r;
    r.w_sum = uReservoirData3Vec.g;
    r.c = uReservoirData3Vec.b;
    r.t = uReservoirData3Vec.a;
    return r;
}

vec4 packReservoir1(Reservoir r) {
    return vec4(
    r.Y.rc_vertex.w,
    r.Y.rc_vertex.L.r,
    r.Y.rc_vertex.L.g,
    r.Y.rc_vertex.L.b
    );
}

vec4 packReservoir2(Reservoir r) {
    return vec4(
    r.Y.epsilon_1,
    r.Y.epsilon_2,
    float(r.Y.k),
    r.Y.J
    );
}

vec4 packReservoir3(Reservoir r) {
    return vec4(
    r.W_Y,
    r.w_sum,
    r.c,
    r.t
    );
}


vec3 evaluateBSDF(vec3 incoming_dir, vec3 outgoing_dir, vec3 normal, vec3 albedo) {
    if (dot(incoming_dir, normal) < 0.0 || dot(outgoing_dir, normal) < 0.0) return vec3(0.0);
    return albedo / pi;
}

float luminance(vec3 L) {
    return max(dot(L, vec3(1.0)), 0.0);
}

float compute_p_hat(float solidAnglePDF, float jacobian) {
    return solidAnglePDF * jacobian;
}

Reservoir tracePath(vec3 ray, vec3 origin) {
    Reservoir localReservoir = initializeReservoir();

    vec3 throughput = vec3(1.0);
    float path_pdf = 1.0;

    vec3 last_pos = vec3(0.0);
    vec3 last_normal = vec3(0.0);
    vec3 last_dir_in = -ray;
    vec3 albedo = vec3(1.0);

    float initSeed = ray.x * 85.63 + ray.y * 53.47 + ray.z * 25.93 + uTime * 49.69;

    int bounce = 0;
    for (bounce = 0; bounce < int(maxBounces); bounce++) {
        float currentSeed = initSeed + float(bounce) * 36.23;
        Isect isect = intersect(origin, ray);
        if (isect.t == infinity) {
            last_pos = origin + ray * infinity;
            last_normal = -ray;
            last_dir_in = -ray;
            albedo = vec3(0.0);
            break;
        }

        last_pos = isect.position;
        last_normal = isect.normal;
        last_dir_in = -ray;
        albedo = isect.albedo;

        vec3 new_dir = cosineWeightedDirection(currentSeed, isect.normal);
        float pdf = pdfCosineWeighted(new_dir, isect.normal);
        if (pdf < 1e-6) break;

        vec3 bsdf = evaluateBSDF(-ray, new_dir, isect.normal, albedo);
        float cosTheta = max(dot(isect.normal, new_dir), 0.0);
        throughput *= bsdf * cosTheta / pdf;
        path_pdf *= pdf;

        origin = isect.position;
        ray = new_dir;
    }

    vec3 light_dir = normalize(light - last_pos);
    float light_dist2 = dot(light - last_pos, light - last_pos);
    float cosTheta = max(dot(last_normal, light_dir), 0.0);
    float visibility = shadow(last_pos + epsilon * last_normal, light - last_pos, sphereCenter, sphereRadius);
    float pdf = pdfCosineWeighted(light_dir, last_normal);

    vec3 Li = vec3(lightIntensity / light_dist2); // multiply by light color if light has color
    vec3 bsdf = evaluateBSDF(last_dir_in, light_dir, last_normal, albedo);
    vec3 f = bsdf * cosTheta;

    vec3 L = f * Li * visibility;
    float w = luminance(L);

    float cosThetaJ = max(dot(last_normal, light_dir), 1e-4);
    float distance2 = dot(light - last_pos, light - last_pos);
    float jacobian = cosThetaJ / distance2;

    float hat_p = compute_p_hat(pdf, jacobian);
    float W = (hat_p > 0.0) ? w / hat_p : 0.0;

    localReservoir.Y.rc_vertex.w = w;
    localReservoir.Y.rc_vertex.L = L;
    localReservoir.Y.epsilon_1 = random(vec3(1.0), initSeed + float(bounce + 1) * 36.23);
    localReservoir.Y.epsilon_2 = random(vec3(1.0), initSeed + float(bounce + 2) * 36.23);
    localReservoir.Y.k = bounce;
    localReservoir.Y.J = jacobian;
    localReservoir.W_Y = W;
    localReservoir.w_sum = W;
    localReservoir.c = 1.0;
    return localReservoir;
}

void main() {
    Reservoir r = tracePath(initialRay, uEye);
    out_ReservoirData1 = packReservoir1(r);
    out_ReservoirData2 = packReservoir2(r);
    out_ReservoirData3 = packReservoir3(r);
}

`;

export const pathTracerVSText = 
`#version 300 es
in vec2 aVertPos;
uniform vec3 uEye, uRay00, uRay01, uRay10, uRay11;
out vec3 initialRay;

void main() {
    vec2 percent = aVertPos.xy * 0.5 + 0.5;
    initialRay = mix(mix(uRay00, uRay01, percent.y), mix(uRay10, uRay11, percent.y), percent.x);
    gl_Position = vec4(aVertPos, 0.0, 1.0);
}
`;

export const pathTracerFSText = 
`#version 300 es
precision highp float;

uniform vec3 uEye;
uniform float uTime;
in vec3 initialRay;

uniform sampler2D uTexture;
uniform float uTextureWeight;
uniform vec2 uRes;vec3 roomCubeMin = vec3(-10.0, -10.0, -10.0);
vec3 roomCubeMax = vec3(10.0, 10.0, 10.0);
vec3 sphereCenter = vec3(0.0, 0.0, 0.0);
float sphereRadius = 1.0;
vec3 light = vec3(0.0, 5.0, 0.0);
float lightIntensity = 1.0;
float infinity = 10000.0;
float epsilon = 0.0001;
float lightSize = 1.0;
float pi = 3.14159265359;
float maxBounces = 100.0;float random(vec3 scale, float seed) {
    return fract(sin(dot(gl_FragCoord.xyz + seed, scale)) * 43758.5453 + seed);
}

vec3 uniformlyRandomDirection(float seed) {
    float u = random(vec3(12.9898, 78.233, 151.7182), seed);
    float v = random(vec3(63.7264, 10.873, 623.6736), seed);
    float z = 1.0 - 2.0 * u;
    float r = sqrt(1.0 - z * z);
    float angle = 6.283185307179586 * v;
    return vec3(r * cos(angle), r * sin(angle), z);
}

vec3 uniformlyRandomVector(float seed) {
    return uniformlyRandomDirection(seed) * sqrt(random(vec3(36.7539, 50.3658, 306.2759), seed));
}vec2 intersectCube(vec3 origin, vec3 ray, vec3 cubeMin, vec3 cubeMax) {
    vec3 tMin = (cubeMin - origin) / ray;
    vec3 tMax = (cubeMax - origin) / ray;
    vec3 t1 = min(tMin, tMax);
    vec3 t2 = max(tMin, tMax);
    float tNear = max(max(t1.x, t1.y), t1.z);
    float tFar = min(min(t2.x, t2.y), t2.z);
    return vec2(tNear, tFar);
}

vec3 normalForCube(vec3 hit, vec3 cubeMin, vec3 cubeMax) {
    if (hit.x < cubeMin.x + epsilon)
    return vec3(-1.0, 0.0, 0.0);
    else if (hit.x > cubeMax.x - epsilon)
    return vec3(1.0, 0.0, 0.0);
    else if (hit.y < cubeMin.y + epsilon)
    return vec3(0.0, -1.0, 0.0);
    else if (hit.y > cubeMax.y - epsilon)
    return vec3(0.0, 1.0, 0.0);
    else if (hit.z < cubeMin.z + epsilon)
    return vec3(0.0, 0.0, -1.0);
    else
    return vec3(0.0, 0.0, 1.0);
}float intersectSphere(vec3 origin, vec3 ray, vec3 sphereCenter, float sphereRadius) {
    vec3 toSphere = origin - sphereCenter;
    float a = dot(ray, ray);
    float b = 2.0 * dot(toSphere, ray);
    float c = dot(toSphere, toSphere) - sphereRadius*sphereRadius;
    float discriminant = b*b - 4.0*a*c;
    if(discriminant > 0.0) {
        float t = (-b - sqrt(discriminant)) / (2.0 * a);
        if(t > 0.0) return t;
    }
    return infinity;
}

vec3 normalForSphere(vec3 hit, vec3 sphereCenter, float sphereRadius) {
    return (hit - sphereCenter) / sphereRadius;
}struct Isect {
    float t; // Distance along the ray
    vec3 position;
    vec3 normal;
    vec3 albedo; // Simplified material color
    bool isLight; // Is the hit surface a light source?
    // vec3 emission; // Light emission color
    float pdf; // PDF of sampling this hit (e.g., light sampling PDF)
};

Isect intersect(vec3 ray, vec3 origin) {
    Isect isect;
    vec2 tRoom = intersectCube(origin, ray, roomCubeMin, roomCubeMax);
    float tSphere = intersectSphere(origin, ray, sphereCenter, sphereRadius);
    float tLight = intersectSphere(origin, ray, light, lightSize);
    float t = infinity;
    if (tRoom.x < tRoom.y) t = tRoom.y;
    if (tSphere < t) t = tSphere;
    if (tLight < t) t = tLight;

    isect.t = t;
    isect.albedo = vec3(0.75);
    isect.position = origin + ray * t;
    // float specularHighlight = 0.0;

    if (t == infinity) {
        return isect;
    }

    if (t == tRoom.y) {
        isect.normal = -normalForCube(isect.position, roomCubeMin, roomCubeMax);
        if(isect.position.x < -9.9999) isect.albedo = vec3(0.1, 0.5, 1.0);
        else if(isect.position.x > 9.9999) isect.albedo = vec3(1.0, 0.9, 0.1);
    } else if (t == tSphere) {
        isect.normal = normalForSphere(isect.position, sphereCenter, sphereRadius);
    } else if (t == tLight) {
        isect.normal = normalForSphere(isect.position, light, lightSize);
        isect.isLight = true;
    }
    return isect;
}vec3 cosineWeightedDirection(float seed, vec3 normal) {
    // Simple cosine-weighted random direction
    float u = random(vec3(12.9898, 78.233, 151.7182), seed);
    float v = random(vec3(63.7264, 10.873, 623.6736), seed);
    float r = sqrt(u);
    float angle = 6.28318530718 * v;
    vec3 sdir, tdir;
    if (abs(normal.x) < .5) {
        sdir = cross(normal, vec3(1,0,0));
    } else {
        sdir = cross(normal, vec3(0,1,0));
    }
    tdir = cross(normal, sdir);
    return normalize(r*cos(angle)*sdir + r*sin(angle)*tdir + sqrt(1.-u)*normal);
}

float pdfCosineWeighted(vec3 direction, vec3 normal) {
    float cosTheta = dot(direction, normal);
    if (cosTheta <= 0.0) return 0.0;
    return cosTheta / pi;
}

float shadow(vec3 origin, vec3 ray, vec3 sphereCenter, float sphereRadius) {
    float t = intersectSphere(origin, ray, sphereCenter, sphereRadius);
    if (t < 1.0) return 0.0;
    return 1.0;
}

out vec4 fragColor;

vec3 calculateColor(vec3 origin, vec3 ray, vec3 light) {
    vec3 colorMask = vec3(1.0);
    vec3 accumulatedColor = vec3(0.0);

    float roulette = random(vec3(1.0), ray.x * 11.87 + ray.y * 78.77 + ray.z * 26.63 + uTime * 51.79);
    int num_iters = int(ceil(log(1.0 - roulette) / log(0.9)));

    for (int bounce = 0; bounce < 100; bounce++) {
        Isect isect = intersect(ray, origin);
        if (isect.t == infinity) {
            break;
        }
        if (isect.isLight) {
            accumulatedColor = vec3(lightIntensity);
            break;
        }

        ray = cosineWeightedDirection(uTime + float(bounce), isect.normal);
        vec3 toLight = light - isect.position;
        float diffuse = max(0.0, dot(normalize(toLight), isect.normal));

        float shadowIntensity = shadow(isect.position + isect.normal * epsilon, toLight, sphereCenter, sphereRadius);

        colorMask *= isect.albedo;
        accumulatedColor += colorMask * (lightIntensity * 0.5 * diffuse * shadowIntensity);
        origin = isect.position;

        if (bounce > num_iters) {
            break;
        }
    }

    return accumulatedColor;
}

void main() {
    float stableTime = floor(uTime * 10.0) / 10.0;
    vec3 newLight = light + uniformlyRandomVector(stableTime - 53.0) * lightSize;

    // Avoid using 'texture' as a variable name
    vec3 texColor = texture(uTexture, gl_FragCoord.xy / uRes).rgb;

    vec3 color = mix(calculateColor(uEye, initialRay, newLight), texColor, uTextureWeight);
    fragColor = vec4(color, 1.0);
}
`;

export const ReSTIR_initialPassFSText = 
`#version 300 es
precision highp float;

uniform vec3 uEye;
uniform vec2 uRes;
uniform float uTime;
in vec3 initialRay;
out vec4 fragColor;

#define NUM_CANDIDATES 8
#define M1 50 // num of bsdf sampled candidates
#define M2 50 // num of light candidates
#define PI 3.14159265359vec3 roomCubeMin = vec3(-10.0, -10.0, -10.0);
vec3 roomCubeMax = vec3(10.0, 10.0, 10.0);
vec3 sphereCenter = vec3(0.0, 0.0, 0.0);
float sphereRadius = 1.0;
vec3 light = vec3(0.0, 5.0, 0.0);
float lightIntensity = 1.0;
float infinity = 10000.0;
float epsilon = 0.0001;
float lightSize = 1.0;
float pi = 3.14159265359;
float maxBounces = 100.0;float intersectSphere(vec3 origin, vec3 ray, vec3 sphereCenter, float sphereRadius) {
    vec3 toSphere = origin - sphereCenter;
    float a = dot(ray, ray);
    float b = 2.0 * dot(toSphere, ray);
    float c = dot(toSphere, toSphere) - sphereRadius*sphereRadius;
    float discriminant = b*b - 4.0*a*c;
    if(discriminant > 0.0) {
        float t = (-b - sqrt(discriminant)) / (2.0 * a);
        if(t > 0.0) return t;
    }
    return infinity;
}

vec3 normalForSphere(vec3 hit, vec3 sphereCenter, float sphereRadius) {
    return (hit - sphereCenter) / sphereRadius;
}vec2 intersectCube(vec3 origin, vec3 ray, vec3 cubeMin, vec3 cubeMax) {
    vec3 tMin = (cubeMin - origin) / ray;
    vec3 tMax = (cubeMax - origin) / ray;
    vec3 t1 = min(tMin, tMax);
    vec3 t2 = max(tMin, tMax);
    float tNear = max(max(t1.x, t1.y), t1.z);
    float tFar = min(min(t2.x, t2.y), t2.z);
    return vec2(tNear, tFar);
}

vec3 normalForCube(vec3 hit, vec3 cubeMin, vec3 cubeMax) {
    if (hit.x < cubeMin.x + epsilon)
    return vec3(-1.0, 0.0, 0.0);
    else if (hit.x > cubeMax.x - epsilon)
    return vec3(1.0, 0.0, 0.0);
    else if (hit.y < cubeMin.y + epsilon)
    return vec3(0.0, -1.0, 0.0);
    else if (hit.y > cubeMax.y - epsilon)
    return vec3(0.0, 1.0, 0.0);
    else if (hit.z < cubeMin.z + epsilon)
    return vec3(0.0, 0.0, -1.0);
    else
    return vec3(0.0, 0.0, 1.0);
}struct Isect {
    float t; // Distance along the ray
    vec3 position;
    vec3 normal;
    vec3 albedo; // Simplified material color
    bool isLight; // Is the hit surface a light source?
    // vec3 emission; // Light emission color
    float pdf; // PDF of sampling this hit (e.g., light sampling PDF)
};

Isect intersect(vec3 ray, vec3 origin) {
    Isect isect;
    vec2 tRoom = intersectCube(origin, ray, roomCubeMin, roomCubeMax);
    float tSphere = intersectSphere(origin, ray, sphereCenter, sphereRadius);
    float tLight = intersectSphere(origin, ray, light, lightSize);
    float t = infinity;
    if (tRoom.x < tRoom.y) t = tRoom.y;
    if (tSphere < t) t = tSphere;
    if (tLight < t) t = tLight;

    isect.t = t;
    isect.albedo = vec3(0.75);
    isect.position = origin + ray * t;
    // float specularHighlight = 0.0;

    if (t == infinity) {
        return isect;
    }

    if (t == tRoom.y) {
        isect.normal = -normalForCube(isect.position, roomCubeMin, roomCubeMax);
        if(isect.position.x < -9.9999) isect.albedo = vec3(0.1, 0.5, 1.0);
        else if(isect.position.x > 9.9999) isect.albedo = vec3(1.0, 0.9, 0.1);
    } else if (t == tSphere) {
        isect.normal = normalForSphere(isect.position, sphereCenter, sphereRadius);
    } else if (t == tLight) {
        isect.normal = normalForSphere(isect.position, light, lightSize);
        isect.isLight = true;
    }
    return isect;
}
struct RCVertex {
    float w;
    vec3 L;
    // todo add triangle Id, barycentric tuple, lobe indices
};

struct Sample_Y {
    RCVertex rc_vertex;
    float epsilon_1;
    float epsilon_2;
    int k;
    float J;
};

struct Reservoir {
    Sample_Y Y;
    float W_Y;
    float w_sum;
    float c;
    float t;
};

Reservoir initializeReservoir() {
    Reservoir r;
    r.Y.rc_vertex.w = 0.0;
    r.Y.rc_vertex.L = vec3(0.0);
    r.Y.epsilon_1 = 0.0;
    r.Y.epsilon_2 = 0.0;
    r.Y.k = 0;
    r.Y.J = 0.0;
    r.W_Y = 0.0;
    r.w_sum = 0.0;
    r.c = 0.0;
    return r;
}

Reservoir unpackReservoir(vec4 uReservoirData1Vec, vec4 uReservoirData2Vec, vec4 uReservoirData3Vec) {
    Reservoir r;
    r.Y.rc_vertex.w = uReservoirData1Vec.r;
    r.Y.rc_vertex.L = uReservoirData1Vec.gba;
    r.Y.epsilon_1 = uReservoirData2Vec.r;
    r.Y.epsilon_2 = uReservoirData2Vec.g;
    r.Y.k = int(uReservoirData2Vec.b);
    r.Y.J = uReservoirData2Vec.a;
    r.W_Y = uReservoirData3Vec.r;
    r.w_sum = uReservoirData3Vec.g;
    r.c = uReservoirData3Vec.b;
    r.t = uReservoirData3Vec.a;
    return r;
}

vec4 packReservoir1(Reservoir r) {
    return vec4(
    r.Y.rc_vertex.w,
    r.Y.rc_vertex.L.r,
    r.Y.rc_vertex.L.g,
    r.Y.rc_vertex.L.b
    );
}

vec4 packReservoir2(Reservoir r) {
    return vec4(
    r.Y.epsilon_1,
    r.Y.epsilon_2,
    float(r.Y.k),
    r.Y.J
    );
}

vec4 packReservoir3(Reservoir r) {
    return vec4(
    r.W_Y,
    r.w_sum,
    r.c,
    r.t
    );
}
float random(vec3 scale, float seed) {
    return fract(sin(dot(gl_FragCoord.xyz + seed, scale)) * 43758.5453 + seed);
}

vec3 uniformlyRandomDirection(float seed) {
    float u = random(vec3(12.9898, 78.233, 151.7182), seed);
    float v = random(vec3(63.7264, 10.873, 623.6736), seed);
    float z = 1.0 - 2.0 * u;
    float r = sqrt(1.0 - z * z);
    float angle = 6.283185307179586 * v;
    return vec3(r * cos(angle), r * sin(angle), z);
}

vec3 uniformlyRandomVector(float seed) {
    return uniformlyRandomDirection(seed) * sqrt(random(vec3(36.7539, 50.3658, 306.2759), seed));
}vec3 cosineWeightedDirection(float seed, vec3 normal) {
    // Simple cosine-weighted random direction
    float u = random(vec3(12.9898, 78.233, 151.7182), seed);
    float v = random(vec3(63.7264, 10.873, 623.6736), seed);
    float r = sqrt(u);
    float angle = 6.28318530718 * v;
    vec3 sdir, tdir;
    if (abs(normal.x) < .5) {
        sdir = cross(normal, vec3(1,0,0));
    } else {
        sdir = cross(normal, vec3(0,1,0));
    }
    tdir = cross(normal, sdir);
    return normalize(r*cos(angle)*sdir + r*sin(angle)*tdir + sqrt(1.-u)*normal);
}

float pdfCosineWeighted(vec3 direction, vec3 normal) {
    float cosTheta = dot(direction, normal);
    if (cosTheta <= 0.0) return 0.0;
    return cosTheta / pi;
}

float shadow(vec3 origin, vec3 ray, vec3 sphereCenter, float sphereRadius) {
    float t = intersectSphere(origin, ray, sphereCenter, sphereRadius);
    if (t < 1.0) return 0.0;
    return 1.0;
}

float rand(vec2 co, float seed) {
    return fract(sin(dot(co.xy + seed, vec2(12.9898, 78.233))) * 43758.5453);
}

// Balance heuristic for MIS weights
float balanceHeuristic(float pI, float pJ, float M_I, float M_J) {
    return (pI) / (M_I * pI + M_J * pJ + 1e-6);
}

// Sample point on sphere
vec3 sampleSphere(vec3 center, float radius, vec2 u) {
    float z = 1.0 - 2.0 * u.x;
    float phi = 2.0 * PI * u.y;
    float r = sqrt(1.0 - z * z);
    return center + radius * vec3(r * cos(phi), r * sin(phi), z);
}

void main() {
    vec3 ray = normalize(initialRay);
    vec3 origin = uEye;

    Isect isect = intersect(ray, origin);
    if (isect.t < 0.0) {
        // Hit nothing, return sky/background color
        fragColor = vec4(0.2, 0.3, 0.5, 1.0);
        return;
    }

    vec3 hitPoint = origin + isect.t * ray;

    // Direct hit on light source
    if (isect.isLight) {
        fragColor = vec4(vec3(1.0), 1.0); // Simple emission
        return;
    }

    // Initialize for RIS
    vec3 selectedDirection;
    float sumWeights = 0.0;
    float sumSamplingWeights = 0.0;
    float selectedPdf = 0.0;
    float selectedMisWeight = 0.0;
    bool sampleFound = false;
    vec2 randUV = gl_FragCoord.xy / uRes;

    for (int i = 0; i < M1+M2; i++) {
        float seed = float(i) + uTime;

        // Determine sampling technique (BSDF or light)
        bool fromLight = bool(i < M2);

        float p1, p2, m1, m2;
        vec3 lightPos;
        vec3 lightDir;
        float lightDist;

        if (fromLight) {
            // --- Sample from light source ---
            vec2 u = vec2(rand(randUV, seed), rand(randUV, seed + 1.0));
            lightPos = sampleSphere(light, lightSize, u);
            lightDir = normalize(lightPos - hitPoint);

            if (dot(isect.normal, lightDir) <= 0.0) continue;

            lightDist = length(lightPos - hitPoint);
            Isect shadowIsect = intersect(lightDir, hitPoint + isect.normal * 0.001);
            if (shadowIsect.t > 0.0 && shadowIsect.t < lightDist - 0.01) continue;
        } else {
            // BSDF
            lightDir = cosineWeightedDirection(seed, isect.normal);

            Isect lightIsect = intersect(lightDir, hitPoint + isect.normal * 0.001);
            if (lightIsect.t < 0.0 || !lightIsect.isLight) continue;

            float lightDist = lightIsect.t;
        }
        float cosLight = max(dot(-lightDir, normalize(lightPos - light)), 0.0);
        float area = 4.0 * PI * lightSize * lightSize;
        float p_light = (lightDist * lightDist) / (area * cosLight + 1e-6);
        float p_bsdf = pdfCosineWeighted(lightDir, isect.normal);
        p1 = fromLight ? p_light : p_bsdf;
        p2 = fromLight ? p_bsdf : p_light;
        m1 = fromLight ? float(M2) : float(M1);
        m2 = fromLight ? float(M1) : float(M2);
        float m_i = balanceHeuristic(p1, p2, m1, m2);
        float p_hat = max(dot(isect.normal, lightDir), 0.0);

        // Skip invalid samples
        if (p_light <= 0.0 || p_bsdf <= 0.0 || p_hat <= 0.0) continue;

        // Compute RIS weight - according to the paper:
        float w_i = m_i * p_hat / p1;
        sumWeights += p_hat / p1;
        sumSamplingWeights += w_i;

        // Reservoir sampling
        if (!sampleFound || rand(randUV, seed + 2.0) * sumSamplingWeights < w_i) {
            selectedDirection = lightDir;
            selectedPdf = p_hat;
            selectedMisWeight = w_i;
            sampleFound = true;
        }
    }

    // No valid samples found
    if (!sampleFound || sumWeights <= 0.0) {
        fragColor = vec4(vec3(0.0), 1.0);
        return;
    }

    // According to the paper: W_X = (1/pÌ‚(X)) * (sum of all weights)
    // This is our unbiased contribution weight
    float M_total = float(M1 + M2);
    float finalWeight = sumWeights / selectedPdf;
    vec3 finalLighting = (isect.albedo / PI) * max(dot(isect.normal, selectedDirection), 0.0);

    // Final color
    fragColor = vec4(finalLighting * finalWeight, 1.0);
}
`;

export const risFSText = 
`#version 300 es
precision highp float;

uniform vec3 uEye;
uniform vec2 uRes;
uniform float uTime;
in vec3 initialRay;
out vec4 fragColor;

#define M 100       // Increase total number of samples for better convergence
#define M1 5       // num of bsdf sampled candidates
#define M2 5       // num of light candidates
#define PI 3.14159265359

// Assuming the macro expansions from your original shadervec3 roomCubeMin = vec3(-10.0, -10.0, -10.0);
vec3 roomCubeMax = vec3(10.0, 10.0, 10.0);
vec3 sphereCenter = vec3(0.0, 0.0, 0.0);
float sphereRadius = 1.0;
vec3 light = vec3(0.0, 5.0, 0.0);
float lightIntensity = 1.0;
float infinity = 10000.0;
float epsilon = 0.0001;
float lightSize = 1.0;
float pi = 3.14159265359;
float maxBounces = 100.0;float intersectSphere(vec3 origin, vec3 ray, vec3 sphereCenter, float sphereRadius) {
    vec3 toSphere = origin - sphereCenter;
    float a = dot(ray, ray);
    float b = 2.0 * dot(toSphere, ray);
    float c = dot(toSphere, toSphere) - sphereRadius*sphereRadius;
    float discriminant = b*b - 4.0*a*c;
    if(discriminant > 0.0) {
        float t = (-b - sqrt(discriminant)) / (2.0 * a);
        if(t > 0.0) return t;
    }
    return infinity;
}

vec3 normalForSphere(vec3 hit, vec3 sphereCenter, float sphereRadius) {
    return (hit - sphereCenter) / sphereRadius;
}vec2 intersectCube(vec3 origin, vec3 ray, vec3 cubeMin, vec3 cubeMax) {
    vec3 tMin = (cubeMin - origin) / ray;
    vec3 tMax = (cubeMax - origin) / ray;
    vec3 t1 = min(tMin, tMax);
    vec3 t2 = max(tMin, tMax);
    float tNear = max(max(t1.x, t1.y), t1.z);
    float tFar = min(min(t2.x, t2.y), t2.z);
    return vec2(tNear, tFar);
}

vec3 normalForCube(vec3 hit, vec3 cubeMin, vec3 cubeMax) {
    if (hit.x < cubeMin.x + epsilon)
    return vec3(-1.0, 0.0, 0.0);
    else if (hit.x > cubeMax.x - epsilon)
    return vec3(1.0, 0.0, 0.0);
    else if (hit.y < cubeMin.y + epsilon)
    return vec3(0.0, -1.0, 0.0);
    else if (hit.y > cubeMax.y - epsilon)
    return vec3(0.0, 1.0, 0.0);
    else if (hit.z < cubeMin.z + epsilon)
    return vec3(0.0, 0.0, -1.0);
    else
    return vec3(0.0, 0.0, 1.0);
}struct Isect {
    float t; // Distance along the ray
    vec3 position;
    vec3 normal;
    vec3 albedo; // Simplified material color
    bool isLight; // Is the hit surface a light source?
    // vec3 emission; // Light emission color
    float pdf; // PDF of sampling this hit (e.g., light sampling PDF)
};

Isect intersect(vec3 ray, vec3 origin) {
    Isect isect;
    vec2 tRoom = intersectCube(origin, ray, roomCubeMin, roomCubeMax);
    float tSphere = intersectSphere(origin, ray, sphereCenter, sphereRadius);
    float tLight = intersectSphere(origin, ray, light, lightSize);
    float t = infinity;
    if (tRoom.x < tRoom.y) t = tRoom.y;
    if (tSphere < t) t = tSphere;
    if (tLight < t) t = tLight;

    isect.t = t;
    isect.albedo = vec3(0.75);
    isect.position = origin + ray * t;
    // float specularHighlight = 0.0;

    if (t == infinity) {
        return isect;
    }

    if (t == tRoom.y) {
        isect.normal = -normalForCube(isect.position, roomCubeMin, roomCubeMax);
        if(isect.position.x < -9.9999) isect.albedo = vec3(0.1, 0.5, 1.0);
        else if(isect.position.x > 9.9999) isect.albedo = vec3(1.0, 0.9, 0.1);
    } else if (t == tSphere) {
        isect.normal = normalForSphere(isect.position, sphereCenter, sphereRadius);
    } else if (t == tLight) {
        isect.normal = normalForSphere(isect.position, light, lightSize);
        isect.isLight = true;
    }
    return isect;
}
struct RCVertex {
    float w;
    vec3 L;
    // todo add triangle Id, barycentric tuple, lobe indices
};

struct Sample_Y {
    RCVertex rc_vertex;
    float epsilon_1;
    float epsilon_2;
    int k;
    float J;
};

struct Reservoir {
    Sample_Y Y;
    float W_Y;
    float w_sum;
    float c;
    float t;
};

Reservoir initializeReservoir() {
    Reservoir r;
    r.Y.rc_vertex.w = 0.0;
    r.Y.rc_vertex.L = vec3(0.0);
    r.Y.epsilon_1 = 0.0;
    r.Y.epsilon_2 = 0.0;
    r.Y.k = 0;
    r.Y.J = 0.0;
    r.W_Y = 0.0;
    r.w_sum = 0.0;
    r.c = 0.0;
    return r;
}

Reservoir unpackReservoir(vec4 uReservoirData1Vec, vec4 uReservoirData2Vec, vec4 uReservoirData3Vec) {
    Reservoir r;
    r.Y.rc_vertex.w = uReservoirData1Vec.r;
    r.Y.rc_vertex.L = uReservoirData1Vec.gba;
    r.Y.epsilon_1 = uReservoirData2Vec.r;
    r.Y.epsilon_2 = uReservoirData2Vec.g;
    r.Y.k = int(uReservoirData2Vec.b);
    r.Y.J = uReservoirData2Vec.a;
    r.W_Y = uReservoirData3Vec.r;
    r.w_sum = uReservoirData3Vec.g;
    r.c = uReservoirData3Vec.b;
    r.t = uReservoirData3Vec.a;
    return r;
}

vec4 packReservoir1(Reservoir r) {
    return vec4(
    r.Y.rc_vertex.w,
    r.Y.rc_vertex.L.r,
    r.Y.rc_vertex.L.g,
    r.Y.rc_vertex.L.b
    );
}

vec4 packReservoir2(Reservoir r) {
    return vec4(
    r.Y.epsilon_1,
    r.Y.epsilon_2,
    float(r.Y.k),
    r.Y.J
    );
}

vec4 packReservoir3(Reservoir r) {
    return vec4(
    r.W_Y,
    r.w_sum,
    r.c,
    r.t
    );
}
float random(vec3 scale, float seed) {
    return fract(sin(dot(gl_FragCoord.xyz + seed, scale)) * 43758.5453 + seed);
}

vec3 uniformlyRandomDirection(float seed) {
    float u = random(vec3(12.9898, 78.233, 151.7182), seed);
    float v = random(vec3(63.7264, 10.873, 623.6736), seed);
    float z = 1.0 - 2.0 * u;
    float r = sqrt(1.0 - z * z);
    float angle = 6.283185307179586 * v;
    return vec3(r * cos(angle), r * sin(angle), z);
}

vec3 uniformlyRandomVector(float seed) {
    return uniformlyRandomDirection(seed) * sqrt(random(vec3(36.7539, 50.3658, 306.2759), seed));
}vec3 cosineWeightedDirection(float seed, vec3 normal) {
    // Simple cosine-weighted random direction
    float u = random(vec3(12.9898, 78.233, 151.7182), seed);
    float v = random(vec3(63.7264, 10.873, 623.6736), seed);
    float r = sqrt(u);
    float angle = 6.28318530718 * v;
    vec3 sdir, tdir;
    if (abs(normal.x) < .5) {
        sdir = cross(normal, vec3(1,0,0));
    } else {
        sdir = cross(normal, vec3(0,1,0));
    }
    tdir = cross(normal, sdir);
    return normalize(r*cos(angle)*sdir + r*sin(angle)*tdir + sqrt(1.-u)*normal);
}

float pdfCosineWeighted(vec3 direction, vec3 normal) {
    float cosTheta = dot(direction, normal);
    if (cosTheta <= 0.0) return 0.0;
    return cosTheta / pi;
}

float shadow(vec3 origin, vec3 ray, vec3 sphereCenter, float sphereRadius) {
    float t = intersectSphere(origin, ray, sphereCenter, sphereRadius);
    if (t < 1.0) return 0.0;
    return 1.0;
}

float rand(vec2 co, float seed) {
    return fract(sin(dot(co.xy + seed, vec2(12.9898, 78.233))) * 43758.5453);
}

// Balance heuristic for MIS weights
float balanceHeuristic(float pI, float pJ, float M_I, float M_J) {
    return (pI * M_I) / (M_I * pI + M_J * pJ + 1e-6);
}

// Sample point on sphere
vec3 sampleSphere(vec3 center, float radius, vec2 u) {
    float z = 1.0 - 2.0 * u.x;
    float phi = 2.0 * PI * u.y;
    float r = sqrt(1.0 - z * z);
    return center + radius * vec3(r * cos(phi), r * sin(phi), z);
}

// Improved shadow ray test
bool isVisible(vec3 from, vec3 to) {
    vec3 dir = normalize(to - from);
    float dist = length(to - from);

    // Offset the ray origin slightly to avoid self-intersection
    Isect shadowIsect = intersect(dir, from + dir * 0.001);

    // No intersection or intersection beyond target point
    return shadowIsect.t < 0.0 || shadowIsect.t > dist - 0.001;
}

void main() {
    vec3 ray = normalize(initialRay);
    vec3 origin = uEye;
    vec2 randUV = gl_FragCoord.xy / uRes;

    // Add time-based jitter for temporal anti-aliasing
    float jitterSeed = uTime * 1234.5678;
    randUV += vec2(rand(randUV, jitterSeed), rand(randUV, jitterSeed + 1.0)) * 0.001;

    Isect isect = intersect(ray, origin);
    if (isect.t < 0.0) {
        // Hit nothing, return sky/background color
        fragColor = vec4(0.2, 0.3, 0.5, 1.0);
        return;
    }

    vec3 hitPoint = origin + isect.t * ray;

    // Direct hit on light source
    if (isect.isLight) {
        fragColor = vec4(vec3(5.0), 1.0); // Increased light emission value
        return;
    }

    // Light properties
    vec3 lightEmission = vec3(5.0); // Light intensity/color

    // Initialize for RIS
    vec3 samples[M];
    float p_hatx[M];
    float p_x[M];
    float weights[M];
    int numSamples = 0;

    float sumWeights = 0.0;

    // Generate candidates
    for (int i = 0; i < M; i++) {
        // Generate different random values for each sample
        float seed1 = float(i) * 0.1 + uTime * 0.5;
        float seed2 = float(i) * 0.2 + uTime * 0.7;
        vec2 u = vec2(rand(randUV, seed1), rand(randUV, seed2));

        // Sample point on light
        vec3 lightPos = sampleSphere(light, lightSize, u);
        vec3 lightDir = normalize(lightPos - isect.position);

        // Skip samples that are not visible or facing away
        if (dot(isect.normal, lightDir) <= 0.0) continue;

        // Perform shadow test
        if (!isVisible(isect.position, lightPos)) continue;

        // Calculate PDFs and weights
        float cosLight = max(0.0, dot(-lightDir, normalize(lightPos - light)));
        float area = 4.0 * PI * lightSize * lightSize;

        // Probability of sampling this point on the light
        float p_light = 1.0 / area;

        // Account for distance falloff
        float dist2 = length(lightPos - isect.position);
        dist2 = dist2 * dist2;

        // BRDF evaluation
        vec3 f = (isect.albedo / PI) * max(dot(isect.normal, lightDir), 0.0);

        // Target function (this will be our estimate of radiance)
        vec3 targetFunction = f * lightEmission * cosLight / dist2;
        float p_hat = length(targetFunction); // Use luminance as target PDF

        if (p_hat <= 0.0) continue;

        // Store the candidate
        samples[numSamples] = lightPos;
        p_hatx[numSamples] = p_hat;
        p_x[numSamples] = p_light;

        // Calculate weight for RIS
        weights[numSamples] = p_hat / p_light;
        sumWeights += weights[numSamples];

        numSamples++;
    }

    // No valid samples found
    if (numSamples == 0 || sumWeights <= 0.0) {
        fragColor = vec4(vec3(0.0), 1.0);
        return;
    }

    // Normalize weights
    for (int i = 0; i < numSamples; i++) {
        weights[i] /= sumWeights;
    }

    // Select one sample based on weights
    float r = rand(randUV, uTime + 123.456);
    int selectedIdx = 0;
    float accumWeight = 0.0;

    for (int i = 0; i < numSamples; i++) {
        accumWeight += weights[i];
        if (r <= accumWeight) {
            selectedIdx = i;
            break;
        }
    }

    // Get the selected sample
    vec3 selectedLightPos = samples[selectedIdx];
    vec3 selectedLightDir = normalize(selectedLightPos - isect.position);

    // Calculate final weight for the selected sample
    float W = sumWeights / float(numSamples);

    // Calculate final contribution
    float dist = length(selectedLightPos - isect.position);
    float cosTheta = max(0.0, dot(isect.normal, selectedLightDir));
    float cosLight = max(0.0, dot(-selectedLightDir, normalize(selectedLightPos - light)));
    vec3 brdf = isect.albedo / PI;

    // Final lighting calculation with correct weighting
    vec3 L = (W * brdf * lightEmission * cosTheta * cosLight) / (dist * dist);

    // Apply a gamma correction to make the image brighter
    L = pow(L, vec3(1.0/2.2));

    // Final color
    fragColor = vec4(L, 1.0);
}
`;

export const spatialReuseFSText = 
`#version 300 es
precision highp float;

uniform vec2 uRes;
uniform sampler2D uReservoirData1;
uniform sampler2D uReservoirData2;
uniform sampler2D uReservoirData3;
uniform float uTime;

out vec4 fragColor; // Replaces gl_FragColorfloat random(vec3 scale, float seed) {
    return fract(sin(dot(gl_FragCoord.xyz + seed, scale)) * 43758.5453 + seed);
}

vec3 uniformlyRandomDirection(float seed) {
    float u = random(vec3(12.9898, 78.233, 151.7182), seed);
    float v = random(vec3(63.7264, 10.873, 623.6736), seed);
    float z = 1.0 - 2.0 * u;
    float r = sqrt(1.0 - z * z);
    float angle = 6.283185307179586 * v;
    return vec3(r * cos(angle), r * sin(angle), z);
}

vec3 uniformlyRandomVector(float seed) {
    return uniformlyRandomDirection(seed) * sqrt(random(vec3(36.7539, 50.3658, 306.2759), seed));
}
struct RCVertex {
    float w;
    vec3 L;
    // todo add triangle Id, barycentric tuple, lobe indices
};

struct Sample_Y {
    RCVertex rc_vertex;
    float epsilon_1;
    float epsilon_2;
    int k;
    float J;
};

struct Reservoir {
    Sample_Y Y;
    float W_Y;
    float w_sum;
    float c;
    float t;
};

Reservoir initializeReservoir() {
    Reservoir r;
    r.Y.rc_vertex.w = 0.0;
    r.Y.rc_vertex.L = vec3(0.0);
    r.Y.epsilon_1 = 0.0;
    r.Y.epsilon_2 = 0.0;
    r.Y.k = 0;
    r.Y.J = 0.0;
    r.W_Y = 0.0;
    r.w_sum = 0.0;
    r.c = 0.0;
    return r;
}

Reservoir unpackReservoir(vec4 uReservoirData1Vec, vec4 uReservoirData2Vec, vec4 uReservoirData3Vec) {
    Reservoir r;
    r.Y.rc_vertex.w = uReservoirData1Vec.r;
    r.Y.rc_vertex.L = uReservoirData1Vec.gba;
    r.Y.epsilon_1 = uReservoirData2Vec.r;
    r.Y.epsilon_2 = uReservoirData2Vec.g;
    r.Y.k = int(uReservoirData2Vec.b);
    r.Y.J = uReservoirData2Vec.a;
    r.W_Y = uReservoirData3Vec.r;
    r.w_sum = uReservoirData3Vec.g;
    r.c = uReservoirData3Vec.b;
    r.t = uReservoirData3Vec.a;
    return r;
}

vec4 packReservoir1(Reservoir r) {
    return vec4(
    r.Y.rc_vertex.w,
    r.Y.rc_vertex.L.r,
    r.Y.rc_vertex.L.g,
    r.Y.rc_vertex.L.b
    );
}

vec4 packReservoir2(Reservoir r) {
    return vec4(
    r.Y.epsilon_1,
    r.Y.epsilon_2,
    float(r.Y.k),
    r.Y.J
    );
}

vec4 packReservoir3(Reservoir r) {
    return vec4(
    r.W_Y,
    r.w_sum,
    r.c,
    r.t
    );
}


void main() {
    vec2 coord = (gl_FragCoord.xy + 0.5) / uRes;

    vec4 uReservoirData1Vec = texture(uReservoirData1, coord);
    vec4 uReservoirData2Vec = texture(uReservoirData2, coord);
    vec4 uReservoirData3Vec = texture(uReservoirData3, coord);

    Reservoir r = unpackReservoir(uReservoirData1Vec, uReservoirData2Vec, uReservoirData3Vec);
    Reservoir r_out = r;
    float new_w_sum = r_out.w_sum;

    float randNum = random(vec3(1.0), gl_FragCoord.x * 29.57 + gl_FragCoord.y * 65.69 + uTime * 82.21);
    float M = 1.0;

    for (int dx = -1; dx <= 1; ++dx) {
        for (int dy = -1; dy <= 1; ++dy) {
            vec2 neighbor = gl_FragCoord.xy + vec2(dx, dy);
            if (neighbor == gl_FragCoord.xy ||
            neighbor.x < 0.0 || neighbor.y < 0.0 ||
            neighbor.x >= uRes.x || neighbor.y >= uRes.y) continue;

            vec2 uv = (neighbor + 0.5) / uRes;

            vec4 uCandidate1 = texture(uReservoirData1, uv);
            vec4 uCandidate2 = texture(uReservoirData2, uv);
            vec4 uCandidate3 = texture(uReservoirData3, uv);

            Reservoir candidate = unpackReservoir(uCandidate1, uCandidate2, uCandidate3);
            float w = candidate.W_Y;

            if (w <= 0.0) continue;

            new_w_sum += w;
            if (randNum < w / new_w_sum) {
                r_out = candidate;
                r_out.w_sum = new_w_sum;
            }
        }
    }

    fragColor = vec4(r_out.Y.rc_vertex.L * r_out.W_Y, 1.0);
}

`;