// Auto-generated by glsl-parser.js


export const drawPassFSText = 
`#version 300 es
precision highp float;

uniform vec3 uEye;
uniform float uTime;
in vec3 initialRay;

uniform sampler2D uTexture;
uniform float uTextureWeight;
uniform vec2 uRes;vec3 roomCubeMin = vec3(-10.0, -10.0, -10.0);
vec3 roomCubeMax = vec3(10.0, 10.0, 10.0);
vec3 wallCubeMax = vec3(10.0, 5.0, 1.0);
vec3 wallCubeMin = vec3(0.0, -10.0, -1.0);
vec3 sphereCenter = vec3(-3.0, -7.0, -3.0);
float sphereRadius = 3.0;
vec3 light = vec3(6.0, 8.0, 6.0);
float lightIntensity = 1.0;
float infinity = 10000.0;
float epsilon = 0.00001;
float lightSize = 0.2;
float pi = 3.14159265359;
float maxBounces = 100.0;
vec3 ReSTIR_lightEmission = vec3(0.5); // Light intensity/colorfloat random(vec3 scale, float seed) {
    return fract(sin(dot(gl_FragCoord.xyz + seed, scale)) * 43758.5453 + seed);
}

float hashCoords(vec2 p) {
    return fract(sin(dot(p, vec2(127.1, 311.7))) * 43758.5453);
}

float hashValue(float p) {
    return fract(sin(p * 43758.5453) * 43758.5453);
}

float rand(vec2 co, float seed) {
    return fract(sin(dot(co.xy + seed, vec2(12.9898, 78.233))) * 43758.5453);
}

vec3 uniformlyRandomDirection(float seed) {
    float u = random(vec3(12.9898, 78.233, 151.7182), seed);
    float v = random(vec3(63.7264, 10.873, 623.6736), seed);
    float z = 1.0 - 2.0 * u;
    float r = sqrt(1.0 - z * z);
    float angle = 6.283185307179586 * v;
    return vec3(r * cos(angle), r * sin(angle), z);
}

vec3 uniformlyRandomVector(float seed) {
    return uniformlyRandomDirection(seed) * sqrt(random(vec3(36.7539, 50.3658, 306.2759), seed));
}

// https://rh8liuqy.github.io/Uniform_Disk.html
vec2 uniformlyRandomDisk(float seed, int radius) {
    float u = random(vec3(12.9898, 78.233, 151.7182), seed);
    float v = random(vec3(63.7264, 10.873, 623.6736), seed + 1.0);
    float x = float(radius) * sqrt(u) * cos(2.0 * pi * u);
    float y = float(radius) * sqrt(v) * sin(2.0 * pi * v);
    return vec2(x, y);
}vec2 intersectCube(vec3 origin, vec3 ray, vec3 cubeMin, vec3 cubeMax) {
    vec3 tMin = (cubeMin - origin) / ray;
    vec3 tMax = (cubeMax - origin) / ray;
    vec3 t1 = min(tMin, tMax);
    vec3 t2 = max(tMin, tMax);
    float tNear = max(max(t1.x, t1.y), t1.z);
    float tFar = min(min(t2.x, t2.y), t2.z);
    return vec2(tNear, tFar);
}

vec3 normalForCube(vec3 hit, vec3 cubeMin, vec3 cubeMax) {
    if (hit.x < cubeMin.x + epsilon)
    return vec3(-1.0, 0.0, 0.0);
    else if (hit.x > cubeMax.x - epsilon)
    return vec3(1.0, 0.0, 0.0);
    else if (hit.y < cubeMin.y + epsilon)
    return vec3(0.0, -1.0, 0.0);
    else if (hit.y > cubeMax.y - epsilon)
    return vec3(0.0, 1.0, 0.0);
    else if (hit.z < cubeMin.z + epsilon)
    return vec3(0.0, 0.0, -1.0);
    else
    return vec3(0.0, 0.0, 1.0);
}float intersectSphere(vec3 origin, vec3 ray, vec3 sphereCenter, float sphereRadius) {
    vec3 toSphere = origin - sphereCenter;
    float a = dot(ray, ray);
    float b = 2.0 * dot(toSphere, ray);
    float c = dot(toSphere, toSphere) - sphereRadius*sphereRadius;
    float discriminant = b*b - 4.0*a*c;
    if(discriminant > 0.0) {
        float t = (-b - sqrt(discriminant)) / (2.0 * a);
        if(t > 0.0) return t;
    }
    return infinity;
}

vec3 normalForSphere(vec3 hit, vec3 sphereCenter, float sphereRadius) {
    return (hit - sphereCenter) / sphereRadius;
}struct Isect {
    float t; // Distance along the ray
    vec3 position;
    vec3 normal;
    vec3 albedo; // Simplified material color
    bool isLight; // Is the hit surface a light source?
    // vec3 emission; // Light emission color
    float pdf; // PDF of sampling this hit (e.g., light sampling PDF)
};

Isect intersect(vec3 ray, vec3 origin) {
    Isect isect;
    vec2 tRoom = intersectCube(origin, ray, roomCubeMin, roomCubeMax);
    float tSphere = intersectSphere(origin, ray, sphereCenter, sphereRadius);
    float tLight = intersectSphere(origin, ray, light, lightSize);
    vec2 tWall = intersectCube(origin, ray, wallCubeMin, wallCubeMax);
    float t = infinity;
    if (tRoom.x < tRoom.y) t = tRoom.y;
    if (tWall.x < tWall.y && tWall.x > epsilon && tWall.x < t) t = tWall.x;
    if (tSphere < t) t = tSphere;
    if (tLight < t) t = tLight;

    isect.t = t;
    isect.albedo = vec3(1.0);
    isect.position = origin + ray * t;
    // float specularHighlight = 0.0;

    if (t == infinity) {
        return isect;
    }

    if (t == tRoom.y) {
        isect.normal = -normalForCube(isect.position, roomCubeMin, roomCubeMax);
        if(isect.position.x < -9.9999) isect.albedo = vec3(0.1, 0.5, 1.0);
        else if(isect.position.x > 9.9999) isect.albedo = vec3(1.0, 0.9, 0.1);
    }  else if (t == tWall.x) {
        isect.normal = normalForCube(isect.position, wallCubeMin, wallCubeMax);
        isect.albedo = vec3(1.0); // Wall color
    } else if (t == tSphere) {
        isect.normal = normalForSphere(isect.position, sphereCenter, sphereRadius);
    } else if (t == tLight) {
        isect.normal = normalForSphere(isect.position, light, lightSize);
        isect.isLight = true;
    }
    return isect;
}vec3 cosineWeightedDirection(float seed, vec3 normal) {
    // Simple cosine-weighted random direction
    float u = random(vec3(12.9898, 78.233, 151.7182), seed);
    float v = random(vec3(63.7264, 10.873, 623.6736), seed);
    float r = sqrt(u);
    float angle = 6.28318530718 * v;
    vec3 sdir, tdir;
    if (abs(normal.x) < .5) {
        sdir = cross(normal, vec3(1,0,0));
    } else {
        sdir = cross(normal, vec3(0,1,0));
    }
    tdir = cross(normal, sdir);
    return normalize(r*cos(angle)*sdir + r*sin(angle)*tdir + sqrt(1.-u)*normal);
}

vec3 uniformSpherePos(vec3 origin, float seed, vec3 center, float radius) {
    float u = random(vec3(12.9898, 78.233, 151.7182), seed);
    float v = random(vec3(63.7264, 10.873, 623.6736), seed);
    float theta = 2.0 * pi * u;
    float phi = acos(2.0 * v - 1.0);
    vec3 lightPoint = center + radius * vec3(cos(theta) * sin(phi), sin(theta) * sin(phi), cos(phi));
    return lightPoint;
}

vec3 uniformSphereDirection(vec3 origin, float seed, vec3 center, float radius) {
    vec3 lightPoint = uniformSpherePos(origin, seed, center, radius);
    return normalize(lightPoint - origin);
}

float pdfCosineWeighted(vec3 direction, vec3 normal) {
    float cosTheta = dot(direction, normal);
    if (cosTheta <= 0.0) return epsilon;
    return cosTheta / pi;
}

float pdfUniformSphere(vec3 direction, vec3 origin) {
    Isect isect = intersect(direction, origin);
    if (isect.isLight) {
        vec3 fromLightDir = -direction;
        float dist2 = dot(fromLightDir, fromLightDir);
        fromLightDir = normalize(fromLightDir);
        vec3 lightNormal = normalize(isect.position - light);
        float cosAtLight = max(0.0, dot(lightNormal, fromLightDir));
        if (cosAtLight < epsilon || dist2 < epsilon) return epsilon;
        float surfaceArea = 4.0 * pi * lightSize * lightSize;
        // Conversion factor from area to solid angle pdf is cos(theta)/dist2 and you divide by conversion factor
        float pArea = (1.0 / surfaceArea) * (dist2 / cosAtLight);
        return pArea;
    }
    return epsilon;
}

float shadow(vec3 origin, vec3 ray, vec3 sphereCenter, float sphereRadius) {
    float t = intersectSphere(origin, ray, sphereCenter, sphereRadius);
    if (t < 1.0) return 0.0;
    return 1.0;
}

float balanceHeuristic(float pdf_a, float nb_pdf_a, float pdf_b, float nb_pdf_b) {
    return pdf_a / (nb_pdf_a * pdf_a + nb_pdf_b * pdf_b + epsilon);
}


out vec4 fragColor;

void main() {
    vec3 texColor = texture(uTexture, gl_FragCoord.xy / uRes).rgb;
    fragColor = vec4(texColor, 1.0);
}
`;

export const pathTracerVSText = 
`#version 300 es
in vec2 aVertPos;
uniform vec3 uEye, uRay00, uRay01, uRay10, uRay11;
out vec3 initialRay;

void main() {
    vec2 percent = aVertPos.xy * 0.5 + 0.5;
    initialRay = normalize(mix(mix(uRay00, uRay01, percent.y), mix(uRay10, uRay11, percent.y), percent.x));
    gl_Position = vec4(aVertPos, 0.0, 1.0);
}
`;

export const pathTracerFSText = 
`#version 300 es
precision highp float;

uniform vec3 uEye;
uniform float uTime;
in vec3 initialRay;

uniform sampler2D uTexture;
uniform float uTextureWeight;
uniform vec2 uRes;vec3 roomCubeMin = vec3(-10.0, -10.0, -10.0);
vec3 roomCubeMax = vec3(10.0, 10.0, 10.0);
vec3 wallCubeMax = vec3(10.0, 5.0, 1.0);
vec3 wallCubeMin = vec3(0.0, -10.0, -1.0);
vec3 sphereCenter = vec3(-3.0, -7.0, -3.0);
float sphereRadius = 3.0;
vec3 light = vec3(6.0, 8.0, 6.0);
float lightIntensity = 1.0;
float infinity = 10000.0;
float epsilon = 0.00001;
float lightSize = 0.2;
float pi = 3.14159265359;
float maxBounces = 100.0;
vec3 ReSTIR_lightEmission = vec3(0.5); // Light intensity/colorfloat random(vec3 scale, float seed) {
    return fract(sin(dot(gl_FragCoord.xyz + seed, scale)) * 43758.5453 + seed);
}

float hashCoords(vec2 p) {
    return fract(sin(dot(p, vec2(127.1, 311.7))) * 43758.5453);
}

float hashValue(float p) {
    return fract(sin(p * 43758.5453) * 43758.5453);
}

float rand(vec2 co, float seed) {
    return fract(sin(dot(co.xy + seed, vec2(12.9898, 78.233))) * 43758.5453);
}

vec3 uniformlyRandomDirection(float seed) {
    float u = random(vec3(12.9898, 78.233, 151.7182), seed);
    float v = random(vec3(63.7264, 10.873, 623.6736), seed);
    float z = 1.0 - 2.0 * u;
    float r = sqrt(1.0 - z * z);
    float angle = 6.283185307179586 * v;
    return vec3(r * cos(angle), r * sin(angle), z);
}

vec3 uniformlyRandomVector(float seed) {
    return uniformlyRandomDirection(seed) * sqrt(random(vec3(36.7539, 50.3658, 306.2759), seed));
}

// https://rh8liuqy.github.io/Uniform_Disk.html
vec2 uniformlyRandomDisk(float seed, int radius) {
    float u = random(vec3(12.9898, 78.233, 151.7182), seed);
    float v = random(vec3(63.7264, 10.873, 623.6736), seed + 1.0);
    float x = float(radius) * sqrt(u) * cos(2.0 * pi * u);
    float y = float(radius) * sqrt(v) * sin(2.0 * pi * v);
    return vec2(x, y);
}vec2 intersectCube(vec3 origin, vec3 ray, vec3 cubeMin, vec3 cubeMax) {
    vec3 tMin = (cubeMin - origin) / ray;
    vec3 tMax = (cubeMax - origin) / ray;
    vec3 t1 = min(tMin, tMax);
    vec3 t2 = max(tMin, tMax);
    float tNear = max(max(t1.x, t1.y), t1.z);
    float tFar = min(min(t2.x, t2.y), t2.z);
    return vec2(tNear, tFar);
}

vec3 normalForCube(vec3 hit, vec3 cubeMin, vec3 cubeMax) {
    if (hit.x < cubeMin.x + epsilon)
    return vec3(-1.0, 0.0, 0.0);
    else if (hit.x > cubeMax.x - epsilon)
    return vec3(1.0, 0.0, 0.0);
    else if (hit.y < cubeMin.y + epsilon)
    return vec3(0.0, -1.0, 0.0);
    else if (hit.y > cubeMax.y - epsilon)
    return vec3(0.0, 1.0, 0.0);
    else if (hit.z < cubeMin.z + epsilon)
    return vec3(0.0, 0.0, -1.0);
    else
    return vec3(0.0, 0.0, 1.0);
}float intersectSphere(vec3 origin, vec3 ray, vec3 sphereCenter, float sphereRadius) {
    vec3 toSphere = origin - sphereCenter;
    float a = dot(ray, ray);
    float b = 2.0 * dot(toSphere, ray);
    float c = dot(toSphere, toSphere) - sphereRadius*sphereRadius;
    float discriminant = b*b - 4.0*a*c;
    if(discriminant > 0.0) {
        float t = (-b - sqrt(discriminant)) / (2.0 * a);
        if(t > 0.0) return t;
    }
    return infinity;
}

vec3 normalForSphere(vec3 hit, vec3 sphereCenter, float sphereRadius) {
    return (hit - sphereCenter) / sphereRadius;
}struct Isect {
    float t; // Distance along the ray
    vec3 position;
    vec3 normal;
    vec3 albedo; // Simplified material color
    bool isLight; // Is the hit surface a light source?
    // vec3 emission; // Light emission color
    float pdf; // PDF of sampling this hit (e.g., light sampling PDF)
};

Isect intersect(vec3 ray, vec3 origin) {
    Isect isect;
    vec2 tRoom = intersectCube(origin, ray, roomCubeMin, roomCubeMax);
    float tSphere = intersectSphere(origin, ray, sphereCenter, sphereRadius);
    float tLight = intersectSphere(origin, ray, light, lightSize);
    vec2 tWall = intersectCube(origin, ray, wallCubeMin, wallCubeMax);
    float t = infinity;
    if (tRoom.x < tRoom.y) t = tRoom.y;
    if (tWall.x < tWall.y && tWall.x > epsilon && tWall.x < t) t = tWall.x;
    if (tSphere < t) t = tSphere;
    if (tLight < t) t = tLight;

    isect.t = t;
    isect.albedo = vec3(1.0);
    isect.position = origin + ray * t;
    // float specularHighlight = 0.0;

    if (t == infinity) {
        return isect;
    }

    if (t == tRoom.y) {
        isect.normal = -normalForCube(isect.position, roomCubeMin, roomCubeMax);
        if(isect.position.x < -9.9999) isect.albedo = vec3(0.1, 0.5, 1.0);
        else if(isect.position.x > 9.9999) isect.albedo = vec3(1.0, 0.9, 0.1);
    }  else if (t == tWall.x) {
        isect.normal = normalForCube(isect.position, wallCubeMin, wallCubeMax);
        isect.albedo = vec3(1.0); // Wall color
    } else if (t == tSphere) {
        isect.normal = normalForSphere(isect.position, sphereCenter, sphereRadius);
    } else if (t == tLight) {
        isect.normal = normalForSphere(isect.position, light, lightSize);
        isect.isLight = true;
    }
    return isect;
}vec3 cosineWeightedDirection(float seed, vec3 normal) {
    // Simple cosine-weighted random direction
    float u = random(vec3(12.9898, 78.233, 151.7182), seed);
    float v = random(vec3(63.7264, 10.873, 623.6736), seed);
    float r = sqrt(u);
    float angle = 6.28318530718 * v;
    vec3 sdir, tdir;
    if (abs(normal.x) < .5) {
        sdir = cross(normal, vec3(1,0,0));
    } else {
        sdir = cross(normal, vec3(0,1,0));
    }
    tdir = cross(normal, sdir);
    return normalize(r*cos(angle)*sdir + r*sin(angle)*tdir + sqrt(1.-u)*normal);
}

vec3 uniformSpherePos(vec3 origin, float seed, vec3 center, float radius) {
    float u = random(vec3(12.9898, 78.233, 151.7182), seed);
    float v = random(vec3(63.7264, 10.873, 623.6736), seed);
    float theta = 2.0 * pi * u;
    float phi = acos(2.0 * v - 1.0);
    vec3 lightPoint = center + radius * vec3(cos(theta) * sin(phi), sin(theta) * sin(phi), cos(phi));
    return lightPoint;
}

vec3 uniformSphereDirection(vec3 origin, float seed, vec3 center, float radius) {
    vec3 lightPoint = uniformSpherePos(origin, seed, center, radius);
    return normalize(lightPoint - origin);
}

float pdfCosineWeighted(vec3 direction, vec3 normal) {
    float cosTheta = dot(direction, normal);
    if (cosTheta <= 0.0) return epsilon;
    return cosTheta / pi;
}

float pdfUniformSphere(vec3 direction, vec3 origin) {
    Isect isect = intersect(direction, origin);
    if (isect.isLight) {
        vec3 fromLightDir = -direction;
        float dist2 = dot(fromLightDir, fromLightDir);
        fromLightDir = normalize(fromLightDir);
        vec3 lightNormal = normalize(isect.position - light);
        float cosAtLight = max(0.0, dot(lightNormal, fromLightDir));
        if (cosAtLight < epsilon || dist2 < epsilon) return epsilon;
        float surfaceArea = 4.0 * pi * lightSize * lightSize;
        // Conversion factor from area to solid angle pdf is cos(theta)/dist2 and you divide by conversion factor
        float pArea = (1.0 / surfaceArea) * (dist2 / cosAtLight);
        return pArea;
    }
    return epsilon;
}

float shadow(vec3 origin, vec3 ray, vec3 sphereCenter, float sphereRadius) {
    float t = intersectSphere(origin, ray, sphereCenter, sphereRadius);
    if (t < 1.0) return 0.0;
    return 1.0;
}

float balanceHeuristic(float pdf_a, float nb_pdf_a, float pdf_b, float nb_pdf_b) {
    return pdf_a / (nb_pdf_a * pdf_a + nb_pdf_b * pdf_b + epsilon);
}


out vec4 fragColor;

vec3 calculateColor(vec3 origin, vec3 ray, vec3 light) {
    vec3 colorMask = vec3(1.0);
    vec3 accumulatedColor = vec3(0.0);

    float russian_roulette_prob = 1.0;
    float total_dist = 0.0;
    for (int bounce = 0; bounce < 50; bounce++) {
        float roulette = random(vec3(36.7539, 50.3658, 306.2759), dot(gl_FragCoord.xy, vec2(12.9898, 78.233)) + uTime * 17.13 + float(bounce) * 91.71);
        if (roulette >= russian_roulette_prob) {
            break;
        }
        colorMask /= russian_roulette_prob;
        Isect isect = intersect(ray, origin);
        if (isect.t == infinity) {
            break;
        }
        if (bounce == 0 && isect.isLight) {
            accumulatedColor += lightIntensity;
        }

        vec3 directRay;
        float ndotr;
        float pdfA;
        float pdfB;
        float misWeight;
        vec3 lightRadianceMIS;
        vec3 bsdfRadianceMIS;
        vec3 nextOrigin = isect.position + isect.normal * epsilon;
        vec3 brdf = isect.albedo / pi;

        // Uniform Light Sample
        directRay = uniformSphereDirection(isect.position, uTime + float(bounce) * 11.71 + ray.x + ray.y * 91.0, light, lightSize);
        pdfA = pdfUniformSphere(directRay, nextOrigin);
        pdfB = pdfCosineWeighted(directRay, isect.normal);
        if (pdfA > epsilon && pdfB > epsilon) {
            misWeight = balanceHeuristic(pdfA, 1.0, pdfB, 1.0);
            ndotr = dot(isect.normal, directRay);
            lightRadianceMIS = brdf * ndotr * lightIntensity * misWeight / pdfA;
        }

        // BSDF Sample
        directRay = cosineWeightedDirection(uTime + float(bounce) * 17.23 + ray.x + ray.y * 11.0 + 11.0, isect.normal);
        pdfA = pdfCosineWeighted(directRay, isect.normal);
        pdfB = pdfUniformSphere(directRay, nextOrigin);
        if (pdfA > epsilon && pdfB > epsilon) {
            misWeight = balanceHeuristic(pdfA, 1.0, pdfB, 1.0);
            ndotr = dot(isect.normal, directRay);
            bsdfRadianceMIS = brdf * ndotr * lightIntensity * misWeight / pdfA;
        }

        vec3 directLightContribution = lightRadianceMIS + bsdfRadianceMIS;
        accumulatedColor += directLightContribution * colorMask;

        vec3 nextRay = cosineWeightedDirection(uTime + float(bounce) * 71.51 + ray.x + ray.y * 61.0 + 23.0, isect.normal);
        float pdfBSDF = pdfCosineWeighted(nextRay, isect.normal);

        if (pdfBSDF <= epsilon) {
            break;
        }

        ndotr = dot(isect.normal, nextRay);
        colorMask *= brdf * abs(ndotr) / pdfBSDF;

        // Russian Roulette Termination
        float throughput_max_element = max(max(colorMask.x, colorMask.y), colorMask.z);

        russian_roulette_prob = min(throughput_max_element, 1.0);

        origin = nextOrigin;
        ray = nextRay;
    }

    return accumulatedColor;
}

void main() {

    // Avoid using 'texture' as a variable name
    vec3 texColor = texture(uTexture, gl_FragCoord.xy / uRes).rgb;

    // vec3 color = mix(calculateColor(uEye, initialRay, light).rgb, texColor, uTextureWeight);
    vec3 color = calculateColor(uEye, initialRay, light);
    fragColor = vec4(color, 1.0);
}
`;

export const ReSTIRGI_spatialPassFSText = 
`#version 300 es
precision highp float;

uniform vec3 uEye, uRay00, uRay01, uRay10, uRay11;
uniform vec2 uRes;
uniform float uTime;
in vec3 initialRay;
out vec4 fragColor;
uniform sampler2D uDirectReservoirData1;
uniform sampler2D uDirectReservoirData2;
uniform sampler2D uIndirectReservoirData1;
uniform sampler2D uIndirectReservoirData2;

#define NB_BSDF 1
#define NB_LIGHT 1vec3 roomCubeMin = vec3(-10.0, -10.0, -10.0);
vec3 roomCubeMax = vec3(10.0, 10.0, 10.0);
vec3 wallCubeMax = vec3(10.0, 5.0, 1.0);
vec3 wallCubeMin = vec3(0.0, -10.0, -1.0);
vec3 sphereCenter = vec3(-3.0, -7.0, -3.0);
float sphereRadius = 3.0;
vec3 light = vec3(6.0, 8.0, 6.0);
float lightIntensity = 1.0;
float infinity = 10000.0;
float epsilon = 0.00001;
float lightSize = 0.2;
float pi = 3.14159265359;
float maxBounces = 100.0;
vec3 ReSTIR_lightEmission = vec3(0.5); // Light intensity/colorfloat random(vec3 scale, float seed) {
    return fract(sin(dot(gl_FragCoord.xyz + seed, scale)) * 43758.5453 + seed);
}

float hashCoords(vec2 p) {
    return fract(sin(dot(p, vec2(127.1, 311.7))) * 43758.5453);
}

float hashValue(float p) {
    return fract(sin(p * 43758.5453) * 43758.5453);
}

float rand(vec2 co, float seed) {
    return fract(sin(dot(co.xy + seed, vec2(12.9898, 78.233))) * 43758.5453);
}

vec3 uniformlyRandomDirection(float seed) {
    float u = random(vec3(12.9898, 78.233, 151.7182), seed);
    float v = random(vec3(63.7264, 10.873, 623.6736), seed);
    float z = 1.0 - 2.0 * u;
    float r = sqrt(1.0 - z * z);
    float angle = 6.283185307179586 * v;
    return vec3(r * cos(angle), r * sin(angle), z);
}

vec3 uniformlyRandomVector(float seed) {
    return uniformlyRandomDirection(seed) * sqrt(random(vec3(36.7539, 50.3658, 306.2759), seed));
}

// https://rh8liuqy.github.io/Uniform_Disk.html
vec2 uniformlyRandomDisk(float seed, int radius) {
    float u = random(vec3(12.9898, 78.233, 151.7182), seed);
    float v = random(vec3(63.7264, 10.873, 623.6736), seed + 1.0);
    float x = float(radius) * sqrt(u) * cos(2.0 * pi * u);
    float y = float(radius) * sqrt(v) * sin(2.0 * pi * v);
    return vec2(x, y);
}float intersectSphere(vec3 origin, vec3 ray, vec3 sphereCenter, float sphereRadius) {
    vec3 toSphere = origin - sphereCenter;
    float a = dot(ray, ray);
    float b = 2.0 * dot(toSphere, ray);
    float c = dot(toSphere, toSphere) - sphereRadius*sphereRadius;
    float discriminant = b*b - 4.0*a*c;
    if(discriminant > 0.0) {
        float t = (-b - sqrt(discriminant)) / (2.0 * a);
        if(t > 0.0) return t;
    }
    return infinity;
}

vec3 normalForSphere(vec3 hit, vec3 sphereCenter, float sphereRadius) {
    return (hit - sphereCenter) / sphereRadius;
}vec2 intersectCube(vec3 origin, vec3 ray, vec3 cubeMin, vec3 cubeMax) {
    vec3 tMin = (cubeMin - origin) / ray;
    vec3 tMax = (cubeMax - origin) / ray;
    vec3 t1 = min(tMin, tMax);
    vec3 t2 = max(tMin, tMax);
    float tNear = max(max(t1.x, t1.y), t1.z);
    float tFar = min(min(t2.x, t2.y), t2.z);
    return vec2(tNear, tFar);
}

vec3 normalForCube(vec3 hit, vec3 cubeMin, vec3 cubeMax) {
    if (hit.x < cubeMin.x + epsilon)
    return vec3(-1.0, 0.0, 0.0);
    else if (hit.x > cubeMax.x - epsilon)
    return vec3(1.0, 0.0, 0.0);
    else if (hit.y < cubeMin.y + epsilon)
    return vec3(0.0, -1.0, 0.0);
    else if (hit.y > cubeMax.y - epsilon)
    return vec3(0.0, 1.0, 0.0);
    else if (hit.z < cubeMin.z + epsilon)
    return vec3(0.0, 0.0, -1.0);
    else
    return vec3(0.0, 0.0, 1.0);
}struct Isect {
    float t; // Distance along the ray
    vec3 position;
    vec3 normal;
    vec3 albedo; // Simplified material color
    bool isLight; // Is the hit surface a light source?
    // vec3 emission; // Light emission color
    float pdf; // PDF of sampling this hit (e.g., light sampling PDF)
};

Isect intersect(vec3 ray, vec3 origin) {
    Isect isect;
    vec2 tRoom = intersectCube(origin, ray, roomCubeMin, roomCubeMax);
    float tSphere = intersectSphere(origin, ray, sphereCenter, sphereRadius);
    float tLight = intersectSphere(origin, ray, light, lightSize);
    vec2 tWall = intersectCube(origin, ray, wallCubeMin, wallCubeMax);
    float t = infinity;
    if (tRoom.x < tRoom.y) t = tRoom.y;
    if (tWall.x < tWall.y && tWall.x > epsilon && tWall.x < t) t = tWall.x;
    if (tSphere < t) t = tSphere;
    if (tLight < t) t = tLight;

    isect.t = t;
    isect.albedo = vec3(1.0);
    isect.position = origin + ray * t;
    // float specularHighlight = 0.0;

    if (t == infinity) {
        return isect;
    }

    if (t == tRoom.y) {
        isect.normal = -normalForCube(isect.position, roomCubeMin, roomCubeMax);
        if(isect.position.x < -9.9999) isect.albedo = vec3(0.1, 0.5, 1.0);
        else if(isect.position.x > 9.9999) isect.albedo = vec3(1.0, 0.9, 0.1);
    }  else if (t == tWall.x) {
        isect.normal = normalForCube(isect.position, wallCubeMin, wallCubeMax);
        isect.albedo = vec3(1.0); // Wall color
    } else if (t == tSphere) {
        isect.normal = normalForSphere(isect.position, sphereCenter, sphereRadius);
    } else if (t == tLight) {
        isect.normal = normalForSphere(isect.position, light, lightSize);
        isect.isLight = true;
    }
    return isect;
}vec3 cosineWeightedDirection(float seed, vec3 normal) {
    // Simple cosine-weighted random direction
    float u = random(vec3(12.9898, 78.233, 151.7182), seed);
    float v = random(vec3(63.7264, 10.873, 623.6736), seed);
    float r = sqrt(u);
    float angle = 6.28318530718 * v;
    vec3 sdir, tdir;
    if (abs(normal.x) < .5) {
        sdir = cross(normal, vec3(1,0,0));
    } else {
        sdir = cross(normal, vec3(0,1,0));
    }
    tdir = cross(normal, sdir);
    return normalize(r*cos(angle)*sdir + r*sin(angle)*tdir + sqrt(1.-u)*normal);
}

vec3 uniformSpherePos(vec3 origin, float seed, vec3 center, float radius) {
    float u = random(vec3(12.9898, 78.233, 151.7182), seed);
    float v = random(vec3(63.7264, 10.873, 623.6736), seed);
    float theta = 2.0 * pi * u;
    float phi = acos(2.0 * v - 1.0);
    vec3 lightPoint = center + radius * vec3(cos(theta) * sin(phi), sin(theta) * sin(phi), cos(phi));
    return lightPoint;
}

vec3 uniformSphereDirection(vec3 origin, float seed, vec3 center, float radius) {
    vec3 lightPoint = uniformSpherePos(origin, seed, center, radius);
    return normalize(lightPoint - origin);
}

float pdfCosineWeighted(vec3 direction, vec3 normal) {
    float cosTheta = dot(direction, normal);
    if (cosTheta <= 0.0) return epsilon;
    return cosTheta / pi;
}

float pdfUniformSphere(vec3 direction, vec3 origin) {
    Isect isect = intersect(direction, origin);
    if (isect.isLight) {
        vec3 fromLightDir = -direction;
        float dist2 = dot(fromLightDir, fromLightDir);
        fromLightDir = normalize(fromLightDir);
        vec3 lightNormal = normalize(isect.position - light);
        float cosAtLight = max(0.0, dot(lightNormal, fromLightDir));
        if (cosAtLight < epsilon || dist2 < epsilon) return epsilon;
        float surfaceArea = 4.0 * pi * lightSize * lightSize;
        // Conversion factor from area to solid angle pdf is cos(theta)/dist2 and you divide by conversion factor
        float pArea = (1.0 / surfaceArea) * (dist2 / cosAtLight);
        return pArea;
    }
    return epsilon;
}

float shadow(vec3 origin, vec3 ray, vec3 sphereCenter, float sphereRadius) {
    float t = intersectSphere(origin, ray, sphereCenter, sphereRadius);
    if (t < 1.0) return 0.0;
    return 1.0;
}

float balanceHeuristic(float pdf_a, float nb_pdf_a, float pdf_b, float nb_pdf_b) {
    return pdf_a / (nb_pdf_a * pdf_a + nb_pdf_b * pdf_b + epsilon);
}
float evaluate_target_function_at_center(vec3 light_sample, Isect isect, vec3 brdf) {
    vec3 sample_direction = normalize(light_sample - isect.position);
    Isect light_isect = intersect(sample_direction, isect.position);
    float visibility = light_isect.isLight ? 1.0 : 0.0;
    float ndotr = dot(isect.normal, sample_direction);
    vec3 contribution = brdf * abs(ndotr) * visibility;
    return dot(contribution, vec3(0.3086, 0.6094, 0.0820));
}
struct ReSTIR_Reservoir {
    vec3 Y;      // light direction or position
    float W_Y;   // selected sample weight
    float p_hat;
    float w_sum; // total weight of all candidates
    float c;    //sample count
    float t; //geometry info
};

ReSTIR_Reservoir initializeReservoir() {
    ReSTIR_Reservoir r;
    r.Y = vec3(0.0);
    r.W_Y = 0.0;
    r.w_sum = 0.0;

    return r;
}

ReSTIR_Reservoir unpackReservoir(vec4 data1, vec4 data2) {
    ReSTIR_Reservoir r;
    r.Y = data1.rgb;        // using .rgb for vec3
    r.p_hat = data1.a;
    r.W_Y = data2.r;
    r.w_sum = data2.g;
    r.t = data2.b;
    r.c = data2.a;
    return r;
}

vec4 packReservoir1(ReSTIR_Reservoir r) {
    return vec4(r.Y, r.p_hat);
}

vec4 packReservoir2(ReSTIR_Reservoir r) {
    return vec4(r.W_Y, r.w_sum, r.t, r.c); // zero pad unused values
}
struct ReSTIRGI_Reservoir {
    vec3 Y;      // sample position (x2)
    float W_Y;   // selected sample weight
    vec3 L;     // indirect light contribution
    float c;    //sample count
};

ReSTIRGI_Reservoir initializeReservoirGI() {
    ReSTIRGI_Reservoir r;
    r.Y = vec3(0.0);
    r.W_Y = 0.0;
    r.L = vec3(0.0);
    r.c = 0.0;

    return r;
}

ReSTIRGI_Reservoir unpackReservoirGI(vec4 data1, vec4 data2) {
    ReSTIRGI_Reservoir r;
    r.Y = data1.rgb;        // using .rgb for vec3
    r.W_Y = data1.a;
    r.L = data2.rgb;        // using .rgb for vec3
    r.c = data2.a;
    return r;
}

vec4 packReservoirGI1(ReSTIRGI_Reservoir r) {
    return vec4(r.Y, r.W_Y);
}

vec4 packReservoirGI2(ReSTIRGI_Reservoir r) {
    return vec4(r.L, r.c); // zero pad unused values
}

ReSTIR_Reservoir reservoirGIToDI(ReSTIRGI_Reservoir r_in) {
    ReSTIR_Reservoir r;
    r.Y = r_in.Y;
    r.W_Y = r_in.W_Y;
    r.p_hat = dot(r_in.L, vec3(0.3086, 0.6094, 0.0820));
    r.w_sum = 0.0; // w_sum is not used in GI
    r.t = 0.0; // t is not used in GI
    r.c = r.c; // c is the sample count
    return r;
}

float luminance(vec3 contrib) {
    return dot(contrib, vec3(0.3086, 0.6094, 0.0820));
}
ReSTIR_Reservoir sample_lights_restir_spatial(vec3 ray, float seed, Isect isectCenter, sampler2D reservoirData1, sampler2D reservoirData2) {
    vec2 uv = gl_FragCoord.xy / uRes;
    ReSTIR_Reservoir rCenter = unpackReservoir(texture(reservoirData1, uv), texture(reservoirData2, uv));
    ReSTIR_Reservoir r = initializeReservoir();
    int MAX_NEIGHBORS = 16;
    ReSTIR_Reservoir candidates[17];
    candidates[0] = rCenter;
    int count = 1;
    float sum_p_hat = rCenter.p_hat;
    vec3 centerBrdf = isectCenter.albedo / pi;
    for (int candidateIndex = 0; candidateIndex < MAX_NEIGHBORS; candidateIndex++) {
        vec2 dxy = uniformlyRandomDisk(hashValue(seed + float(candidateIndex)), 8);
        vec2 neighbor = gl_FragCoord.xy + vec2(int(dxy.x), int(dxy.y));
        if (neighbor.x < 0.0 || neighbor.y < 0.0 ||
        neighbor.x >= uRes.x || neighbor.y >= uRes.y) continue;

        vec2 uv = (neighbor) / uRes;

        vec4 uCandidate1 = texture(reservoirData1, uv);
        vec4 uCandidate2 = texture(reservoirData2, uv);

        candidates[count] = unpackReservoir(uCandidate1, uCandidate2);
        vec2 percent = (neighbor / uRes);
        vec3 candidateRay = normalize(mix(mix(uRay00, uRay01, percent.y), mix(uRay10, uRay11, percent.y), percent.x));
        Isect candidateIsect = intersect(candidateRay, uEye);

        if (
            dot(candidateIsect.normal, isectCenter.normal) < 0.95 ||
            abs(candidateIsect.t - isectCenter.t) / isectCenter.t > 0.3 ||
            abs(candidateIsect.t - isectCenter.t) / isectCenter.t < 0.1)
        continue;

        // generate X_i
        sum_p_hat += candidates[count].p_hat;
        r.c += candidates[count].c;
        count++;
    }
    if (sum_p_hat <= epsilon) return r;
    for (int i = 0; i < MAX_NEIGHBORS + 1; i++) {
        if (i >= count) break;
        ReSTIR_Reservoir r_i = candidates[i];
        float m_i = r_i.p_hat/sum_p_hat;
        float p_hat_at_center = evaluate_target_function_at_center(r_i.Y, isectCenter, centerBrdf);
        float w_i = m_i * p_hat_at_center * r_i.W_Y;
        float randint = random(vec3(71.31, 67.73, 91.83), hashValue(seed + float(i)));
        r.w_sum += w_i;
        if (randint < w_i / r.w_sum) {
            r.Y = r_i.Y;
            r.p_hat = p_hat_at_center;
        }
    }
    if (r.w_sum == 0.0 || r.p_hat <= epsilon) {
        return r;
    }
    r.W_Y = r.w_sum / r.p_hat;
    return r;
}
ReSTIRGI_Reservoir sampleLightsReSTIRGISpatial(vec3 ray, float seed, Isect isectCenter, sampler2D reservoirData1, sampler2D reservoirData2) {
    vec2 uv = gl_FragCoord.xy / uRes;
    ReSTIRGI_Reservoir rCenter = unpackReservoirGI(texture(reservoirData1, uv), texture(reservoirData2, uv));
    ReSTIRGI_Reservoir r = initializeReservoirGI();
    int MAX_NEIGHBORS = 16;
    ReSTIRGI_Reservoir candidates[17];
    candidates[0] = rCenter;
    int count = 1;
    float sum_p_hat = luminance(rCenter.L);
    vec3 centerBrdf = isectCenter.albedo / pi;
    for (int candidateIndex = 0; candidateIndex < MAX_NEIGHBORS; candidateIndex++) {
        vec2 dxy = uniformlyRandomDisk(hashValue(seed + float(candidateIndex)), 8);
        vec2 neighbor = gl_FragCoord.xy + vec2(int(dxy.x), int(dxy.y));
        if (neighbor.x < 0.0 || neighbor.y < 0.0 ||
        neighbor.x >= uRes.x || neighbor.y >= uRes.y) continue;

        vec2 uv = (neighbor) / uRes;

        vec4 uCandidate1 = texture(reservoirData1, uv);
        vec4 uCandidate2 = texture(reservoirData2, uv);

        candidates[count] = unpackReservoirGI(uCandidate1, uCandidate2);
        vec3 candidateRay = normalize(candidates[count].Y - isectCenter.position);
        Isect candidateIsect = intersect(candidateRay, isectCenter.position);
        if (abs(distance(candidateIsect.position, candidates[count].Y)) > epsilon) continue;
//        vec2 percent = (neighbor / uRes);
//        vec3 candidateRay = normalize(mix(mix(uRay00, uRay01, percent.y), mix(uRay10, uRay11, percent.y), percent.x));
//        Isect candidateIsect = intersect(candidateRay, uEye);
//
//        if (
//        dot(candidateIsect.normal, isectCenter.normal) < 0.95 ||
//        abs(candidateIsect.t - isectCenter.t) / isectCenter.t > 0.3 ||
//        abs(candidateIsect.t - isectCenter.t) / isectCenter.t < 0.1)
//        continue;

        // generate X_i
        sum_p_hat += luminance(candidates[count].L);
        r.c += candidates[count].c;
        count++;
    }
    if (sum_p_hat <= epsilon) return r;
    float w_sum = 0.0;
    for (int i = 0; i < MAX_NEIGHBORS + 1; i++) {
        if (i >= count) break;
        ReSTIRGI_Reservoir r_i = candidates[i];
        float m_i = luminance(r_i.L)/sum_p_hat;
        float p_hat_at_center = luminance(r_i.L);
        float w_i = m_i * p_hat_at_center * r_i.W_Y;
        float randint = random(vec3(71.31, 67.73, 91.83), hashValue(seed + float(i)));
        w_sum += w_i;
        if (randint < w_i / w_sum) {
            r.Y = r_i.Y;
            r.L = r_i.L;
        }
    }
    if (w_sum == 0.0 || luminance(r.L) <= epsilon) {
        return r;
    }
    r.W_Y = w_sum / luminance(r.L);
    return r;
}ReSTIR_Reservoir sample_lights_ris(ReSTIR_Reservoir r_in, Isect isect, vec3 ray, int nb_bsdf, int nb_light, float seed) {
    ReSTIR_Reservoir r = r_in;
    int M = nb_bsdf + nb_light;
    vec3 nextOrigin = isect.position + isect.normal * epsilon;
    float baseSeed = hashValue(float(M) * 23.0 + 79.0) + seed;

    for (int candidate = 0; candidate < M; candidate++) {
        vec3 next_ray = ray;
        vec3 light_sample;
        float cBaseSeed = baseSeed * 17.51 + hashValue(float(candidate)) * 119.73;

        float reservoirWeight = 0.0;
        bool usedCosine = candidate < NB_BSDF;
        if (usedCosine) {
            next_ray = cosineWeightedDirection(cBaseSeed + 11.37, isect.normal);
            // is bsdf so need to check if ray ends at light
            Isect next_isect = intersect(next_ray, nextOrigin);
            if (!next_isect.isLight) {
                continue;
            }
            light_sample = next_isect.position;
        } else {
            light_sample = uniformSpherePos(isect.position, cBaseSeed + 23.57, light, lightSize);
            next_ray = normalize(light_sample - isect.position);
        }

        float pdfCosine = pdfCosineWeighted(next_ray, isect.normal);
        float pdfLight = pdfUniformSphere(next_ray, isect.position);

        float pdfA = usedCosine? pdfCosine : pdfLight;
        float pdfB = usedCosine? pdfLight : pdfCosine;
        float nbPdfA = float(usedCosine ? NB_BSDF : NB_LIGHT);
        float nbPdfB = float(usedCosine ? NB_LIGHT : NB_BSDF);
        float misWeight = balanceHeuristic(pdfA, nbPdfA, pdfB, nbPdfB);

        float pdfX = max(epsilon, usedCosine ? pdfCosine : pdfLight);

        vec3 brdf = isect.albedo / pi;
        float ndotr = dot(isect.normal, next_ray);
        float pHat = evaluate_target_function_at_center(light_sample, isect, brdf);

        if (ndotr <= epsilon || pHat <= epsilon || pdfX <= epsilon) {
            continue;
        }

        reservoirWeight = misWeight * pHat / pdfX;
        r.w_sum += reservoirWeight;
        float reservoirStrategy = random(vec3(1.0), cBaseSeed + 7.23);
        if (reservoirStrategy < reservoirWeight / r.w_sum) {
            r.p_hat = pHat;
            r.Y = light_sample;
            r.t = isect.t;
        }
    }

    if (r.w_sum > 0.0) {
        r.W_Y = r.w_sum / max(r.p_hat, epsilon);
    }
    r.c = 1.0;
    return r;
}

vec3 calculateColor(vec3 origin, vec3 ray, vec3 light) {
    vec3 colorMask = vec3(1.0);
    vec3 accumulatedColor = vec3(0.0);
    vec3 directLight = vec3(0.0);

    float timeEntropy = hashValue(uTime);
    float seed = hashCoords(gl_FragCoord.xy + timeEntropy * vec2(1.0, -1.0));
    vec2 uv = gl_FragCoord.xy / uRes;

    Isect isect = intersect(ray, origin); // x1
    if (isect.t == infinity) {
        return accumulatedColor;
    }
    vec3 nextOrigin = isect.position + isect.normal * epsilon;
    ReSTIR_Reservoir r = sample_lights_restir_spatial(ray, seed, isect, uDirectReservoirData1, uDirectReservoirData2);
    r.c = min(512.0, r.c);

    if (isect.isLight) {
        accumulatedColor += lightIntensity;
    }

    if (r.w_sum > 0.0) {
        vec3 brdf = isect.albedo / pi;
        vec3 sample_direction = normalize(r.Y - isect.position);
        float ndotr = dot(isect.normal, sample_direction);
        directLight = lightIntensity * brdf * abs(ndotr) * r.W_Y;
        accumulatedColor += colorMask * directLight;
    }

//    vec4 indirectReservoirData1 = texture(uIndirectReservoirData1, uv);
//    vec4 indirectReservoirData2 = texture(uIndirectReservoirData2, uv);
//    ReSTIRGI_Reservoir indirectReservoir = unpackReservoirGI(indirectReservoirData1, indirectReservoirData2);
    ReSTIRGI_Reservoir indirectReservoir = sampleLightsReSTIRGISpatial(ray, seed, isect, uIndirectReservoirData1, uIndirectReservoirData2);
    accumulatedColor += indirectReservoir.L * indirectReservoir.W_Y;

    return accumulatedColor;
}

void main() {
    vec3 color = calculateColor(uEye, initialRay, light);
    fragColor = vec4(color, 1.0);
}
`;

export const ReSTIRGI_temporalPassFSText = 
`#version 300 es
precision highp float;

uniform vec3 uEye, uRay00, uRay01, uRay10, uRay11;
uniform vec2 uRes;
uniform float uTime;
uniform mat4 uViewMatPrev;
uniform mat4 uProjMatPrev;
in vec3 initialRay;

// previous state data
uniform sampler2D uDirectReservoirData1;
uniform sampler2D uDirectReservoirData2;
uniform sampler2D uIndirectReservoirData1;
uniform sampler2D uIndirectReservoirData2;

layout(location = 0) out vec4 out_DirectReservoirData1;
layout(location = 1) out vec4 out_DirectReservoirData2;
layout(location = 2) out vec4 out_IndirectReservoirData1;
layout(location = 3) out vec4 out_IndirectReservoirData2;

#define NB_BSDF 1
#define NB_LIGHT 1vec3 roomCubeMin = vec3(-10.0, -10.0, -10.0);
vec3 roomCubeMax = vec3(10.0, 10.0, 10.0);
vec3 wallCubeMax = vec3(10.0, 5.0, 1.0);
vec3 wallCubeMin = vec3(0.0, -10.0, -1.0);
vec3 sphereCenter = vec3(-3.0, -7.0, -3.0);
float sphereRadius = 3.0;
vec3 light = vec3(6.0, 8.0, 6.0);
float lightIntensity = 1.0;
float infinity = 10000.0;
float epsilon = 0.00001;
float lightSize = 0.2;
float pi = 3.14159265359;
float maxBounces = 100.0;
vec3 ReSTIR_lightEmission = vec3(0.5); // Light intensity/colorfloat intersectSphere(vec3 origin, vec3 ray, vec3 sphereCenter, float sphereRadius) {
    vec3 toSphere = origin - sphereCenter;
    float a = dot(ray, ray);
    float b = 2.0 * dot(toSphere, ray);
    float c = dot(toSphere, toSphere) - sphereRadius*sphereRadius;
    float discriminant = b*b - 4.0*a*c;
    if(discriminant > 0.0) {
        float t = (-b - sqrt(discriminant)) / (2.0 * a);
        if(t > 0.0) return t;
    }
    return infinity;
}

vec3 normalForSphere(vec3 hit, vec3 sphereCenter, float sphereRadius) {
    return (hit - sphereCenter) / sphereRadius;
}vec2 intersectCube(vec3 origin, vec3 ray, vec3 cubeMin, vec3 cubeMax) {
    vec3 tMin = (cubeMin - origin) / ray;
    vec3 tMax = (cubeMax - origin) / ray;
    vec3 t1 = min(tMin, tMax);
    vec3 t2 = max(tMin, tMax);
    float tNear = max(max(t1.x, t1.y), t1.z);
    float tFar = min(min(t2.x, t2.y), t2.z);
    return vec2(tNear, tFar);
}

vec3 normalForCube(vec3 hit, vec3 cubeMin, vec3 cubeMax) {
    if (hit.x < cubeMin.x + epsilon)
    return vec3(-1.0, 0.0, 0.0);
    else if (hit.x > cubeMax.x - epsilon)
    return vec3(1.0, 0.0, 0.0);
    else if (hit.y < cubeMin.y + epsilon)
    return vec3(0.0, -1.0, 0.0);
    else if (hit.y > cubeMax.y - epsilon)
    return vec3(0.0, 1.0, 0.0);
    else if (hit.z < cubeMin.z + epsilon)
    return vec3(0.0, 0.0, -1.0);
    else
    return vec3(0.0, 0.0, 1.0);
}struct Isect {
    float t; // Distance along the ray
    vec3 position;
    vec3 normal;
    vec3 albedo; // Simplified material color
    bool isLight; // Is the hit surface a light source?
    // vec3 emission; // Light emission color
    float pdf; // PDF of sampling this hit (e.g., light sampling PDF)
};

Isect intersect(vec3 ray, vec3 origin) {
    Isect isect;
    vec2 tRoom = intersectCube(origin, ray, roomCubeMin, roomCubeMax);
    float tSphere = intersectSphere(origin, ray, sphereCenter, sphereRadius);
    float tLight = intersectSphere(origin, ray, light, lightSize);
    vec2 tWall = intersectCube(origin, ray, wallCubeMin, wallCubeMax);
    float t = infinity;
    if (tRoom.x < tRoom.y) t = tRoom.y;
    if (tWall.x < tWall.y && tWall.x > epsilon && tWall.x < t) t = tWall.x;
    if (tSphere < t) t = tSphere;
    if (tLight < t) t = tLight;

    isect.t = t;
    isect.albedo = vec3(1.0);
    isect.position = origin + ray * t;
    // float specularHighlight = 0.0;

    if (t == infinity) {
        return isect;
    }

    if (t == tRoom.y) {
        isect.normal = -normalForCube(isect.position, roomCubeMin, roomCubeMax);
        if(isect.position.x < -9.9999) isect.albedo = vec3(0.1, 0.5, 1.0);
        else if(isect.position.x > 9.9999) isect.albedo = vec3(1.0, 0.9, 0.1);
    }  else if (t == tWall.x) {
        isect.normal = normalForCube(isect.position, wallCubeMin, wallCubeMax);
        isect.albedo = vec3(1.0); // Wall color
    } else if (t == tSphere) {
        isect.normal = normalForSphere(isect.position, sphereCenter, sphereRadius);
    } else if (t == tLight) {
        isect.normal = normalForSphere(isect.position, light, lightSize);
        isect.isLight = true;
    }
    return isect;
}
struct ReSTIR_Reservoir {
    vec3 Y;      // light direction or position
    float W_Y;   // selected sample weight
    float p_hat;
    float w_sum; // total weight of all candidates
    float c;    //sample count
    float t; //geometry info
};

ReSTIR_Reservoir initializeReservoir() {
    ReSTIR_Reservoir r;
    r.Y = vec3(0.0);
    r.W_Y = 0.0;
    r.w_sum = 0.0;

    return r;
}

ReSTIR_Reservoir unpackReservoir(vec4 data1, vec4 data2) {
    ReSTIR_Reservoir r;
    r.Y = data1.rgb;        // using .rgb for vec3
    r.p_hat = data1.a;
    r.W_Y = data2.r;
    r.w_sum = data2.g;
    r.t = data2.b;
    r.c = data2.a;
    return r;
}

vec4 packReservoir1(ReSTIR_Reservoir r) {
    return vec4(r.Y, r.p_hat);
}

vec4 packReservoir2(ReSTIR_Reservoir r) {
    return vec4(r.W_Y, r.w_sum, r.t, r.c); // zero pad unused values
}
struct ReSTIRGI_Reservoir {
    vec3 Y;      // sample position (x2)
    float W_Y;   // selected sample weight
    vec3 L;     // indirect light contribution
    float c;    //sample count
};

ReSTIRGI_Reservoir initializeReservoirGI() {
    ReSTIRGI_Reservoir r;
    r.Y = vec3(0.0);
    r.W_Y = 0.0;
    r.L = vec3(0.0);
    r.c = 0.0;

    return r;
}

ReSTIRGI_Reservoir unpackReservoirGI(vec4 data1, vec4 data2) {
    ReSTIRGI_Reservoir r;
    r.Y = data1.rgb;        // using .rgb for vec3
    r.W_Y = data1.a;
    r.L = data2.rgb;        // using .rgb for vec3
    r.c = data2.a;
    return r;
}

vec4 packReservoirGI1(ReSTIRGI_Reservoir r) {
    return vec4(r.Y, r.W_Y);
}

vec4 packReservoirGI2(ReSTIRGI_Reservoir r) {
    return vec4(r.L, r.c); // zero pad unused values
}

ReSTIR_Reservoir reservoirGIToDI(ReSTIRGI_Reservoir r_in) {
    ReSTIR_Reservoir r;
    r.Y = r_in.Y;
    r.W_Y = r_in.W_Y;
    r.p_hat = dot(r_in.L, vec3(0.3086, 0.6094, 0.0820));
    r.w_sum = 0.0; // w_sum is not used in GI
    r.t = 0.0; // t is not used in GI
    r.c = r.c; // c is the sample count
    return r;
}

float luminance(vec3 contrib) {
    return dot(contrib, vec3(0.3086, 0.6094, 0.0820));
}float random(vec3 scale, float seed) {
    return fract(sin(dot(gl_FragCoord.xyz + seed, scale)) * 43758.5453 + seed);
}

float hashCoords(vec2 p) {
    return fract(sin(dot(p, vec2(127.1, 311.7))) * 43758.5453);
}

float hashValue(float p) {
    return fract(sin(p * 43758.5453) * 43758.5453);
}

float rand(vec2 co, float seed) {
    return fract(sin(dot(co.xy + seed, vec2(12.9898, 78.233))) * 43758.5453);
}

vec3 uniformlyRandomDirection(float seed) {
    float u = random(vec3(12.9898, 78.233, 151.7182), seed);
    float v = random(vec3(63.7264, 10.873, 623.6736), seed);
    float z = 1.0 - 2.0 * u;
    float r = sqrt(1.0 - z * z);
    float angle = 6.283185307179586 * v;
    return vec3(r * cos(angle), r * sin(angle), z);
}

vec3 uniformlyRandomVector(float seed) {
    return uniformlyRandomDirection(seed) * sqrt(random(vec3(36.7539, 50.3658, 306.2759), seed));
}

// https://rh8liuqy.github.io/Uniform_Disk.html
vec2 uniformlyRandomDisk(float seed, int radius) {
    float u = random(vec3(12.9898, 78.233, 151.7182), seed);
    float v = random(vec3(63.7264, 10.873, 623.6736), seed + 1.0);
    float x = float(radius) * sqrt(u) * cos(2.0 * pi * u);
    float y = float(radius) * sqrt(v) * sin(2.0 * pi * v);
    return vec2(x, y);
}vec3 cosineWeightedDirection(float seed, vec3 normal) {
    // Simple cosine-weighted random direction
    float u = random(vec3(12.9898, 78.233, 151.7182), seed);
    float v = random(vec3(63.7264, 10.873, 623.6736), seed);
    float r = sqrt(u);
    float angle = 6.28318530718 * v;
    vec3 sdir, tdir;
    if (abs(normal.x) < .5) {
        sdir = cross(normal, vec3(1,0,0));
    } else {
        sdir = cross(normal, vec3(0,1,0));
    }
    tdir = cross(normal, sdir);
    return normalize(r*cos(angle)*sdir + r*sin(angle)*tdir + sqrt(1.-u)*normal);
}

vec3 uniformSpherePos(vec3 origin, float seed, vec3 center, float radius) {
    float u = random(vec3(12.9898, 78.233, 151.7182), seed);
    float v = random(vec3(63.7264, 10.873, 623.6736), seed);
    float theta = 2.0 * pi * u;
    float phi = acos(2.0 * v - 1.0);
    vec3 lightPoint = center + radius * vec3(cos(theta) * sin(phi), sin(theta) * sin(phi), cos(phi));
    return lightPoint;
}

vec3 uniformSphereDirection(vec3 origin, float seed, vec3 center, float radius) {
    vec3 lightPoint = uniformSpherePos(origin, seed, center, radius);
    return normalize(lightPoint - origin);
}

float pdfCosineWeighted(vec3 direction, vec3 normal) {
    float cosTheta = dot(direction, normal);
    if (cosTheta <= 0.0) return epsilon;
    return cosTheta / pi;
}

float pdfUniformSphere(vec3 direction, vec3 origin) {
    Isect isect = intersect(direction, origin);
    if (isect.isLight) {
        vec3 fromLightDir = -direction;
        float dist2 = dot(fromLightDir, fromLightDir);
        fromLightDir = normalize(fromLightDir);
        vec3 lightNormal = normalize(isect.position - light);
        float cosAtLight = max(0.0, dot(lightNormal, fromLightDir));
        if (cosAtLight < epsilon || dist2 < epsilon) return epsilon;
        float surfaceArea = 4.0 * pi * lightSize * lightSize;
        // Conversion factor from area to solid angle pdf is cos(theta)/dist2 and you divide by conversion factor
        float pArea = (1.0 / surfaceArea) * (dist2 / cosAtLight);
        return pArea;
    }
    return epsilon;
}

float shadow(vec3 origin, vec3 ray, vec3 sphereCenter, float sphereRadius) {
    float t = intersectSphere(origin, ray, sphereCenter, sphereRadius);
    if (t < 1.0) return 0.0;
    return 1.0;
}

float balanceHeuristic(float pdf_a, float nb_pdf_a, float pdf_b, float nb_pdf_b) {
    return pdf_a / (nb_pdf_a * pdf_a + nb_pdf_b * pdf_b + epsilon);
}
float evaluate_target_function_at_center(vec3 light_sample, Isect isect, vec3 brdf) {
    vec3 sample_direction = normalize(light_sample - isect.position);
    Isect light_isect = intersect(sample_direction, isect.position);
    float visibility = light_isect.isLight ? 1.0 : 0.0;
    float ndotr = dot(isect.normal, sample_direction);
    vec3 contribution = brdf * abs(ndotr) * visibility;
    return dot(contribution, vec3(0.3086, 0.6094, 0.0820));
}vec2 getPrevUV(Isect isect) {
    vec4 pWorld = vec4(isect.position, 1.0);
    vec4 clip_prev = uProjMatPrev * uViewMatPrev * pWorld;
    if (clip_prev.w < epsilon) {
        return vec2(-1.0); // invalid UV
    }
    vec3 ndc_prev = clip_prev.xyz / clip_prev.w;
    return ndc_prev.xy * 0.5 + 0.5; // convert to [0, 1] range
}


ReSTIR_Reservoir getTemporalNeighborFromTexture(Isect isectCenter, sampler2D reservoirData1, sampler2D reservoirData2) {
    ReSTIR_Reservoir r = initializeReservoir();
    vec2 uv_prev = getPrevUV(isectCenter);
    if (uv_prev.x < 0.0 || uv_prev.x >= 1.0 || uv_prev.y < 0.0 || uv_prev.y >= 1.0) {
        return r;
    }

    // fetch temporal neighbor
    vec4 uReservoirData1Vec = texture(reservoirData1, uv_prev);
    vec4 uReservoirData2Vec = texture(reservoirData2, uv_prev);
    ReSTIR_Reservoir r_prev = unpackReservoir(uReservoirData1Vec, uReservoirData2Vec);

    if (r_prev.W_Y < epsilon) {
        return r;
    }

    return r_prev;
}

ReSTIRGI_Reservoir getTemporalNeighborFromTextureGI(Isect isectCenter, sampler2D reservoirData1, sampler2D reservoirData2) {
    ReSTIRGI_Reservoir r = initializeReservoirGI();
    vec2 uv_prev = getPrevUV(isectCenter);
    if (uv_prev.x < 0.0 || uv_prev.x >= 1.0 || uv_prev.y < 0.0 || uv_prev.y >= 1.0) {
        return r;
    }

    // fetch temporal neighbor
    vec4 uReservoirData1Vec = texture(reservoirData1, uv_prev);
    vec4 uReservoirData2Vec = texture(reservoirData2, uv_prev);
    ReSTIRGI_Reservoir r_prev = unpackReservoirGI(uReservoirData1Vec, uReservoirData2Vec);

    if (r_prev.W_Y < epsilon) {
        return r;
    }

    return r_prev;
}

ReSTIR_Reservoir resample_temporal_base(ReSTIR_Reservoir r_current, ReSTIR_Reservoir r_prev, Isect isectCenter, float seed, bool use_p_hat, out bool acceptCurrent) {
    ReSTIR_Reservoir r_out = initializeReservoir();
    float misWeight;
    float reservoirWeight;
    float reservoirStrategy;
    vec3 centerBrdf = isectCenter.albedo / pi;
    float neighborTargetFunctionAtCenter = use_p_hat ? r_prev.p_hat : evaluate_target_function_at_center(r_prev.Y, isectCenter, centerBrdf);
    float centerTargetFunctionAtCenter = r_current.p_hat;

    ReSTIR_Reservoir[2] reservoirs = ReSTIR_Reservoir[2](r_prev, r_current);
    float[2] targetFunctions = float[2](neighborTargetFunctionAtCenter, centerTargetFunctionAtCenter);
    acceptCurrent = false;
    for (int i = 0; i < 2; i++) {
        if (targetFunctions[i] < epsilon) {
            continue;
        }
        // resample initial candidates
        misWeight = reservoirs[i].c * targetFunctions[i] / (r_prev.c * neighborTargetFunctionAtCenter + r_current.c * centerTargetFunctionAtCenter);
        reservoirWeight = misWeight * targetFunctions[i] * reservoirs[i].W_Y;
        r_out.w_sum += reservoirWeight;
        r_out.c += reservoirs[i].c;
        reservoirStrategy = random(vec3(67.71, 31.91, 83.17), seed + float(i));
        if (reservoirStrategy < reservoirWeight / r_out.w_sum) {
            r_out.p_hat = targetFunctions[i];
            r_out.Y = reservoirs[i].Y;
            r_out.t = reservoirs[i].t;
            acceptCurrent = i == 1; // accept the current reservoir if it's the second one (center)
        }
    }

    r_out.W_Y = r_out.w_sum / r_out.p_hat;
    return r_out;
}

ReSTIR_Reservoir resample_temporal(ReSTIR_Reservoir r_current, ReSTIR_Reservoir r_prev, Isect isectCenter, float seed) {
    bool acceptCurrent;
    return resample_temporal_base(r_current, r_prev, isectCenter, seed, false, acceptCurrent);
}

ReSTIRGI_Reservoir resample_temporalGI(ReSTIRGI_Reservoir r_current, ReSTIRGI_Reservoir r_prev, Isect isectCenter, float seed) {
    bool acceptCurrent;
    ReSTIRGI_Reservoir r_out_gi = initializeReservoirGI();
    ReSTIR_Reservoir r_out = resample_temporal_base(reservoirGIToDI(r_current), reservoirGIToDI(r_prev), isectCenter, seed, true, acceptCurrent);
    if (acceptCurrent) {
        r_out_gi = r_current;
    } else {
        r_out_gi = r_prev;
    }
    r_out_gi.W_Y = r_out.W_Y;
    return r_out_gi;
}ReSTIR_Reservoir sample_lights_ris(ReSTIR_Reservoir r_in, Isect isect, vec3 ray, int nb_bsdf, int nb_light, float seed) {
    ReSTIR_Reservoir r = r_in;
    int M = nb_bsdf + nb_light;
    vec3 nextOrigin = isect.position + isect.normal * epsilon;
    float baseSeed = hashValue(float(M) * 23.0 + 79.0) + seed;

    for (int candidate = 0; candidate < M; candidate++) {
        vec3 next_ray = ray;
        vec3 light_sample;
        float cBaseSeed = baseSeed * 17.51 + hashValue(float(candidate)) * 119.73;

        float reservoirWeight = 0.0;
        bool usedCosine = candidate < NB_BSDF;
        if (usedCosine) {
            next_ray = cosineWeightedDirection(cBaseSeed + 11.37, isect.normal);
            // is bsdf so need to check if ray ends at light
            Isect next_isect = intersect(next_ray, nextOrigin);
            if (!next_isect.isLight) {
                continue;
            }
            light_sample = next_isect.position;
        } else {
            light_sample = uniformSpherePos(isect.position, cBaseSeed + 23.57, light, lightSize);
            next_ray = normalize(light_sample - isect.position);
        }

        float pdfCosine = pdfCosineWeighted(next_ray, isect.normal);
        float pdfLight = pdfUniformSphere(next_ray, isect.position);

        float pdfA = usedCosine? pdfCosine : pdfLight;
        float pdfB = usedCosine? pdfLight : pdfCosine;
        float nbPdfA = float(usedCosine ? NB_BSDF : NB_LIGHT);
        float nbPdfB = float(usedCosine ? NB_LIGHT : NB_BSDF);
        float misWeight = balanceHeuristic(pdfA, nbPdfA, pdfB, nbPdfB);

        float pdfX = max(epsilon, usedCosine ? pdfCosine : pdfLight);

        vec3 brdf = isect.albedo / pi;
        float ndotr = dot(isect.normal, next_ray);
        float pHat = evaluate_target_function_at_center(light_sample, isect, brdf);

        if (ndotr <= epsilon || pHat <= epsilon || pdfX <= epsilon) {
            continue;
        }

        reservoirWeight = misWeight * pHat / pdfX;
        r.w_sum += reservoirWeight;
        float reservoirStrategy = random(vec3(1.0), cBaseSeed + 7.23);
        if (reservoirStrategy < reservoirWeight / r.w_sum) {
            r.p_hat = pHat;
            r.Y = light_sample;
            r.t = isect.t;
        }
    }

    if (r.w_sum > 0.0) {
        r.W_Y = r.w_sum / max(r.p_hat, epsilon);
    }
    r.c = 1.0;
    return r;
}
ReSTIR_Reservoir getTemporalNeighborDI(Isect isectCenter, ReSTIR_Reservoir r_current, sampler2D reservoirData1, sampler2D reservoirData2) {
    ReSTIR_Reservoir temporalNeighbor = getTemporalNeighborFromTexture(isectCenter, reservoirData1, reservoirData2);
    ReSTIR_Reservoir defaultReservoir = initializeReservoir();
    if (temporalNeighbor.W_Y < epsilon) {
        return defaultReservoir;
    }
    vec3 lightDir = normalize(temporalNeighbor.Y - isectCenter.position);
    vec3 rayOrigin = isectCenter.position + isectCenter.normal * epsilon;
    Isect visibilityCheck = intersect(lightDir, rayOrigin);

    // If we dont hit the light there is occlusion
    if (!visibilityCheck.isLight || abs(r_current.t - temporalNeighbor.t) > 0.1 * r_current.t) {
        return defaultReservoir;
    }
    return temporalNeighbor;
}

ReSTIR_Reservoir sampleLightsTemporalDI(vec3 ray, float seed, Isect isectCenter, sampler2D reservoirData1, sampler2D reservoirData2) {
    ReSTIR_Reservoir r_in = initializeReservoir();
    ReSTIR_Reservoir r_current = sample_lights_ris(r_in, isectCenter, ray, NB_BSDF, NB_LIGHT, seed);
    ReSTIR_Reservoir r_prev = getTemporalNeighborDI(isectCenter, r_current, reservoirData1, reservoirData2);

    if (r_prev.W_Y < epsilon) {
        return r_current;
    }

    ReSTIR_Reservoir r_out = resample_temporal(r_current, r_prev, isectCenter, seed);
    return r_out;
}ReSTIRGI_Reservoir getTemporalNeighborGI(Isect isectCenter, sampler2D reservoirData1, sampler2D reservoirData2) {
    ReSTIRGI_Reservoir temporalNeighbor = getTemporalNeighborFromTextureGI(isectCenter, reservoirData1, reservoirData2);
    ReSTIRGI_Reservoir defaultReservoir = initializeReservoirGI();
    if (temporalNeighbor.W_Y < epsilon) {
        return defaultReservoir;
    }
    vec3 rayDir = normalize(temporalNeighbor.Y - isectCenter.position);
    float rayDist = length(temporalNeighbor.Y - isectCenter.position);
    vec3 rayOrigin = isectCenter.position + isectCenter.normal * epsilon;
    Isect visibilityCheck = intersect(rayDir, rayOrigin);

    // if we dont hit the sample spot, there is occlusion
    if (abs(length(visibilityCheck.position - temporalNeighbor.Y) - rayDist) > 0.1 * rayDist) {
        return defaultReservoir;
    }
    return temporalNeighbor;
}

ReSTIRGI_Reservoir samplePath(vec3 ray, float seed, Isect isectCenter) {
    ReSTIRGI_Reservoir r = initializeReservoirGI();
    ReSTIRGI_Reservoir defaultReservoir = initializeReservoirGI();
    ReSTIR_Reservoir r_RIS = initializeReservoir();
    vec3 colorMask = vec3(1.0);
    vec3 accumulatedColor = vec3(0.0);
    vec3 directLight = vec3(0.0);
    vec3 origin = uEye;

    float timeEntropy = hashValue(uTime);
    vec2 uv = gl_FragCoord.xy / uRes;
    float russian_roulette_prob = 1.0;
    float pdfX = 0.0;
    for (int bounce = 0; bounce < 50; bounce++) {
        float roulette = random(vec3(36.7539, 50.3658, 306.2759), dot(gl_FragCoord.xy, vec2(12.9898, 78.233)) + uTime * 17.13 + float(bounce) * 91.71);
        if (roulette >= russian_roulette_prob) {
            break;
        }
        colorMask /= russian_roulette_prob;

        Isect isect;
        if (bounce == 0) isect = isectCenter;
        else isect = intersect(ray, origin);

        if (isect.t == infinity) {
            break;
        }

        if (bounce == 1) {
            r.Y = isect.position;
        }

        vec3 nextOrigin = isect.position + isect.normal * epsilon;
        float baseSeed = hashValue(float(bounce) * 51.19 + 79.0) + seed;

        if (bounce > 0) {
            // simulate direct lighting for our path (bounce > 0)
            r_RIS = initializeReservoir();
            r_RIS = sample_lights_ris(r_RIS, isect, ray, NB_BSDF, NB_LIGHT, baseSeed);

            if (r_RIS.w_sum > 0.0) {
                vec3 brdf = isect.albedo / pi;
                vec3 sample_direction = normalize(r_RIS.Y - isect.position);
                float ndotr = dot(isect.normal, sample_direction);
                directLight = lightIntensity * brdf * abs(ndotr) * r_RIS.W_Y;
                accumulatedColor += colorMask * directLight;
            }
        }
        vec3 nextRay = cosineWeightedDirection(baseSeed, isect.normal);
        float pdfCosine = pdfCosineWeighted(nextRay, isect.normal);
        if (bounce == 0) {
            pdfX = pdfCosine;
        }
        float ndotr = dot(isect.normal, nextRay);
        if (ndotr <= 0.0 || pdfCosine <= epsilon) break;
        vec3 brdf = isect.albedo / pi;
        colorMask *= brdf * ndotr / pdfCosine;

        // Russian Roulette Termination
        float throughput_max_element = max(max(colorMask.x, colorMask.y), colorMask.z);

        russian_roulette_prob = min(throughput_max_element, 1.0);
        origin = nextOrigin;
        ray = nextRay;
    }
    r.L = accumulatedColor;
    if (pdfX < epsilon || dot(r.L, vec3(1.0, 1.0, 1.0)) < epsilon) {
        return defaultReservoir;
    }
    // r.t = isectCenter.t;
    r.c = 1.0;
    r.W_Y = 1.0; // w_sum = p_hat/pdfX, W_Y = w_sum / p_hat = p_hat/pdfX/p_hat = pdfX
    return r;
}

ReSTIRGI_Reservoir sampleLightsTemporalGI(vec3 ray, float seed, Isect isectCenter, sampler2D reservoirData1, sampler2D reservoirData2) {
    ReSTIRGI_Reservoir r_current = samplePath(ray, seed, isectCenter);
    ReSTIRGI_Reservoir r_prev = getTemporalNeighborGI(isectCenter, reservoirData1, reservoirData2);

    if (r_prev.W_Y < epsilon) {
        return r_current;
    }

    ReSTIRGI_Reservoir r_out = resample_temporalGI(r_current, r_prev, isectCenter, seed);
    return r_out;
}

void main() {
    vec3 ray = normalize(initialRay);
    float timeEntropy = hashValue(uTime);
    float seed = hashCoords(gl_FragCoord.xy + timeEntropy * vec2(1.0, -1.0));

    Isect isect = intersect(ray, uEye);
    ReSTIR_Reservoir r_direct = sampleLightsTemporalDI(ray, seed, isect, uDirectReservoirData1, uDirectReservoirData2);
    out_DirectReservoirData1 = packReservoir1(r_direct);
    out_DirectReservoirData2 = packReservoir2(r_direct);
    ReSTIRGI_Reservoir r_indirect = sampleLightsTemporalGI(ray, seed, isect, uIndirectReservoirData1, uIndirectReservoirData2);
    out_IndirectReservoirData1 = packReservoirGI1(r_indirect);
    out_IndirectReservoirData2 = packReservoirGI2(r_indirect);
}

`;

export const ReSTIR_initialPassFSText = 
`#version 300 es
precision highp float;

uniform vec3 uEye;
uniform vec2 uRes;
uniform float uTime;
in vec3 initialRay;
layout(location = 0) out vec4 out_ReservoirData1;
layout(location = 1) out vec4 out_ReservoirData2;

#define NB_BSDF 1
#define NB_LIGHT 1vec3 roomCubeMin = vec3(-10.0, -10.0, -10.0);
vec3 roomCubeMax = vec3(10.0, 10.0, 10.0);
vec3 wallCubeMax = vec3(10.0, 5.0, 1.0);
vec3 wallCubeMin = vec3(0.0, -10.0, -1.0);
vec3 sphereCenter = vec3(-3.0, -7.0, -3.0);
float sphereRadius = 3.0;
vec3 light = vec3(6.0, 8.0, 6.0);
float lightIntensity = 1.0;
float infinity = 10000.0;
float epsilon = 0.00001;
float lightSize = 0.2;
float pi = 3.14159265359;
float maxBounces = 100.0;
vec3 ReSTIR_lightEmission = vec3(0.5); // Light intensity/colorfloat random(vec3 scale, float seed) {
    return fract(sin(dot(gl_FragCoord.xyz + seed, scale)) * 43758.5453 + seed);
}

float hashCoords(vec2 p) {
    return fract(sin(dot(p, vec2(127.1, 311.7))) * 43758.5453);
}

float hashValue(float p) {
    return fract(sin(p * 43758.5453) * 43758.5453);
}

float rand(vec2 co, float seed) {
    return fract(sin(dot(co.xy + seed, vec2(12.9898, 78.233))) * 43758.5453);
}

vec3 uniformlyRandomDirection(float seed) {
    float u = random(vec3(12.9898, 78.233, 151.7182), seed);
    float v = random(vec3(63.7264, 10.873, 623.6736), seed);
    float z = 1.0 - 2.0 * u;
    float r = sqrt(1.0 - z * z);
    float angle = 6.283185307179586 * v;
    return vec3(r * cos(angle), r * sin(angle), z);
}

vec3 uniformlyRandomVector(float seed) {
    return uniformlyRandomDirection(seed) * sqrt(random(vec3(36.7539, 50.3658, 306.2759), seed));
}

// https://rh8liuqy.github.io/Uniform_Disk.html
vec2 uniformlyRandomDisk(float seed, int radius) {
    float u = random(vec3(12.9898, 78.233, 151.7182), seed);
    float v = random(vec3(63.7264, 10.873, 623.6736), seed + 1.0);
    float x = float(radius) * sqrt(u) * cos(2.0 * pi * u);
    float y = float(radius) * sqrt(v) * sin(2.0 * pi * v);
    return vec2(x, y);
}vec2 intersectCube(vec3 origin, vec3 ray, vec3 cubeMin, vec3 cubeMax) {
    vec3 tMin = (cubeMin - origin) / ray;
    vec3 tMax = (cubeMax - origin) / ray;
    vec3 t1 = min(tMin, tMax);
    vec3 t2 = max(tMin, tMax);
    float tNear = max(max(t1.x, t1.y), t1.z);
    float tFar = min(min(t2.x, t2.y), t2.z);
    return vec2(tNear, tFar);
}

vec3 normalForCube(vec3 hit, vec3 cubeMin, vec3 cubeMax) {
    if (hit.x < cubeMin.x + epsilon)
    return vec3(-1.0, 0.0, 0.0);
    else if (hit.x > cubeMax.x - epsilon)
    return vec3(1.0, 0.0, 0.0);
    else if (hit.y < cubeMin.y + epsilon)
    return vec3(0.0, -1.0, 0.0);
    else if (hit.y > cubeMax.y - epsilon)
    return vec3(0.0, 1.0, 0.0);
    else if (hit.z < cubeMin.z + epsilon)
    return vec3(0.0, 0.0, -1.0);
    else
    return vec3(0.0, 0.0, 1.0);
}float intersectSphere(vec3 origin, vec3 ray, vec3 sphereCenter, float sphereRadius) {
    vec3 toSphere = origin - sphereCenter;
    float a = dot(ray, ray);
    float b = 2.0 * dot(toSphere, ray);
    float c = dot(toSphere, toSphere) - sphereRadius*sphereRadius;
    float discriminant = b*b - 4.0*a*c;
    if(discriminant > 0.0) {
        float t = (-b - sqrt(discriminant)) / (2.0 * a);
        if(t > 0.0) return t;
    }
    return infinity;
}

vec3 normalForSphere(vec3 hit, vec3 sphereCenter, float sphereRadius) {
    return (hit - sphereCenter) / sphereRadius;
}struct Isect {
    float t; // Distance along the ray
    vec3 position;
    vec3 normal;
    vec3 albedo; // Simplified material color
    bool isLight; // Is the hit surface a light source?
    // vec3 emission; // Light emission color
    float pdf; // PDF of sampling this hit (e.g., light sampling PDF)
};

Isect intersect(vec3 ray, vec3 origin) {
    Isect isect;
    vec2 tRoom = intersectCube(origin, ray, roomCubeMin, roomCubeMax);
    float tSphere = intersectSphere(origin, ray, sphereCenter, sphereRadius);
    float tLight = intersectSphere(origin, ray, light, lightSize);
    vec2 tWall = intersectCube(origin, ray, wallCubeMin, wallCubeMax);
    float t = infinity;
    if (tRoom.x < tRoom.y) t = tRoom.y;
    if (tWall.x < tWall.y && tWall.x > epsilon && tWall.x < t) t = tWall.x;
    if (tSphere < t) t = tSphere;
    if (tLight < t) t = tLight;

    isect.t = t;
    isect.albedo = vec3(1.0);
    isect.position = origin + ray * t;
    // float specularHighlight = 0.0;

    if (t == infinity) {
        return isect;
    }

    if (t == tRoom.y) {
        isect.normal = -normalForCube(isect.position, roomCubeMin, roomCubeMax);
        if(isect.position.x < -9.9999) isect.albedo = vec3(0.1, 0.5, 1.0);
        else if(isect.position.x > 9.9999) isect.albedo = vec3(1.0, 0.9, 0.1);
    }  else if (t == tWall.x) {
        isect.normal = normalForCube(isect.position, wallCubeMin, wallCubeMax);
        isect.albedo = vec3(1.0); // Wall color
    } else if (t == tSphere) {
        isect.normal = normalForSphere(isect.position, sphereCenter, sphereRadius);
    } else if (t == tLight) {
        isect.normal = normalForSphere(isect.position, light, lightSize);
        isect.isLight = true;
    }
    return isect;
}vec3 cosineWeightedDirection(float seed, vec3 normal) {
    // Simple cosine-weighted random direction
    float u = random(vec3(12.9898, 78.233, 151.7182), seed);
    float v = random(vec3(63.7264, 10.873, 623.6736), seed);
    float r = sqrt(u);
    float angle = 6.28318530718 * v;
    vec3 sdir, tdir;
    if (abs(normal.x) < .5) {
        sdir = cross(normal, vec3(1,0,0));
    } else {
        sdir = cross(normal, vec3(0,1,0));
    }
    tdir = cross(normal, sdir);
    return normalize(r*cos(angle)*sdir + r*sin(angle)*tdir + sqrt(1.-u)*normal);
}

vec3 uniformSpherePos(vec3 origin, float seed, vec3 center, float radius) {
    float u = random(vec3(12.9898, 78.233, 151.7182), seed);
    float v = random(vec3(63.7264, 10.873, 623.6736), seed);
    float theta = 2.0 * pi * u;
    float phi = acos(2.0 * v - 1.0);
    vec3 lightPoint = center + radius * vec3(cos(theta) * sin(phi), sin(theta) * sin(phi), cos(phi));
    return lightPoint;
}

vec3 uniformSphereDirection(vec3 origin, float seed, vec3 center, float radius) {
    vec3 lightPoint = uniformSpherePos(origin, seed, center, radius);
    return normalize(lightPoint - origin);
}

float pdfCosineWeighted(vec3 direction, vec3 normal) {
    float cosTheta = dot(direction, normal);
    if (cosTheta <= 0.0) return epsilon;
    return cosTheta / pi;
}

float pdfUniformSphere(vec3 direction, vec3 origin) {
    Isect isect = intersect(direction, origin);
    if (isect.isLight) {
        vec3 fromLightDir = -direction;
        float dist2 = dot(fromLightDir, fromLightDir);
        fromLightDir = normalize(fromLightDir);
        vec3 lightNormal = normalize(isect.position - light);
        float cosAtLight = max(0.0, dot(lightNormal, fromLightDir));
        if (cosAtLight < epsilon || dist2 < epsilon) return epsilon;
        float surfaceArea = 4.0 * pi * lightSize * lightSize;
        // Conversion factor from area to solid angle pdf is cos(theta)/dist2 and you divide by conversion factor
        float pArea = (1.0 / surfaceArea) * (dist2 / cosAtLight);
        return pArea;
    }
    return epsilon;
}

float shadow(vec3 origin, vec3 ray, vec3 sphereCenter, float sphereRadius) {
    float t = intersectSphere(origin, ray, sphereCenter, sphereRadius);
    if (t < 1.0) return 0.0;
    return 1.0;
}

float balanceHeuristic(float pdf_a, float nb_pdf_a, float pdf_b, float nb_pdf_b) {
    return pdf_a / (nb_pdf_a * pdf_a + nb_pdf_b * pdf_b + epsilon);
}
float evaluate_target_function_at_center(vec3 light_sample, Isect isect, vec3 brdf) {
    vec3 sample_direction = normalize(light_sample - isect.position);
    Isect light_isect = intersect(sample_direction, isect.position);
    float visibility = light_isect.isLight ? 1.0 : 0.0;
    float ndotr = dot(isect.normal, sample_direction);
    vec3 contribution = brdf * abs(ndotr) * visibility;
    return dot(contribution, vec3(0.3086, 0.6094, 0.0820));
}
struct ReSTIR_Reservoir {
    vec3 Y;      // light direction or position
    float W_Y;   // selected sample weight
    float p_hat;
    float w_sum; // total weight of all candidates
    float c;    //sample count
    float t; //geometry info
};

ReSTIR_Reservoir initializeReservoir() {
    ReSTIR_Reservoir r;
    r.Y = vec3(0.0);
    r.W_Y = 0.0;
    r.w_sum = 0.0;

    return r;
}

ReSTIR_Reservoir unpackReservoir(vec4 data1, vec4 data2) {
    ReSTIR_Reservoir r;
    r.Y = data1.rgb;        // using .rgb for vec3
    r.p_hat = data1.a;
    r.W_Y = data2.r;
    r.w_sum = data2.g;
    r.t = data2.b;
    r.c = data2.a;
    return r;
}

vec4 packReservoir1(ReSTIR_Reservoir r) {
    return vec4(r.Y, r.p_hat);
}

vec4 packReservoir2(ReSTIR_Reservoir r) {
    return vec4(r.W_Y, r.w_sum, r.t, r.c); // zero pad unused values
}
ReSTIR_Reservoir sample_lights_ris(ReSTIR_Reservoir r_in, Isect isect, vec3 ray, int nb_bsdf, int nb_light, float seed) {
    ReSTIR_Reservoir r = r_in;
    int M = nb_bsdf + nb_light;
    vec3 nextOrigin = isect.position + isect.normal * epsilon;
    float baseSeed = hashValue(float(M) * 23.0 + 79.0) + seed;

    for (int candidate = 0; candidate < M; candidate++) {
        vec3 next_ray = ray;
        vec3 light_sample;
        float cBaseSeed = baseSeed * 17.51 + hashValue(float(candidate)) * 119.73;

        float reservoirWeight = 0.0;
        bool usedCosine = candidate < NB_BSDF;
        if (usedCosine) {
            next_ray = cosineWeightedDirection(cBaseSeed + 11.37, isect.normal);
            // is bsdf so need to check if ray ends at light
            Isect next_isect = intersect(next_ray, nextOrigin);
            if (!next_isect.isLight) {
                continue;
            }
            light_sample = next_isect.position;
        } else {
            light_sample = uniformSpherePos(isect.position, cBaseSeed + 23.57, light, lightSize);
            next_ray = normalize(light_sample - isect.position);
        }

        float pdfCosine = pdfCosineWeighted(next_ray, isect.normal);
        float pdfLight = pdfUniformSphere(next_ray, isect.position);

        float pdfA = usedCosine? pdfCosine : pdfLight;
        float pdfB = usedCosine? pdfLight : pdfCosine;
        float nbPdfA = float(usedCosine ? NB_BSDF : NB_LIGHT);
        float nbPdfB = float(usedCosine ? NB_LIGHT : NB_BSDF);
        float misWeight = balanceHeuristic(pdfA, nbPdfA, pdfB, nbPdfB);

        float pdfX = max(epsilon, usedCosine ? pdfCosine : pdfLight);

        vec3 brdf = isect.albedo / pi;
        float ndotr = dot(isect.normal, next_ray);
        float pHat = evaluate_target_function_at_center(light_sample, isect, brdf);

        if (ndotr <= epsilon || pHat <= epsilon || pdfX <= epsilon) {
            continue;
        }

        reservoirWeight = misWeight * pHat / pdfX;
        r.w_sum += reservoirWeight;
        float reservoirStrategy = random(vec3(1.0), cBaseSeed + 7.23);
        if (reservoirStrategy < reservoirWeight / r.w_sum) {
            r.p_hat = pHat;
            r.Y = light_sample;
            r.t = isect.t;
        }
    }

    if (r.w_sum > 0.0) {
        r.W_Y = r.w_sum / max(r.p_hat, epsilon);
    }
    r.c = 1.0;
    return r;
}

ReSTIR_Reservoir resampleInitialRay(vec3 origin, vec3 ray, vec3 light) {

    float timeEntropy = hashValue(uTime);
    float seed = hashValue(hashCoords(gl_FragCoord.xy + timeEntropy * vec2(1.0, -1.0)));
    float total_dist = 0.0;
    Isect isect = intersect(ray, origin);
    ReSTIR_Reservoir r = initializeReservoir();
    return sample_lights_ris(r, isect, ray, NB_BSDF, NB_LIGHT, seed);
}

void main() {
    vec3 ray = normalize(initialRay);
    vec3 origin = uEye;
    ReSTIR_Reservoir r = resampleInitialRay(origin, ray, light);
    out_ReservoirData1 = packReservoir1(r);
    out_ReservoirData2 = packReservoir2(r);
}
`;

export const ReSTIR_spatialPassFSText = 
`#version 300 es
precision highp float;

uniform vec3 uEye, uRay00, uRay01, uRay10, uRay11;
uniform vec2 uRes;
uniform float uTime;
in vec3 initialRay;
out vec4 fragColor;
uniform sampler2D uReservoirData1;
uniform sampler2D uReservoirData2;

#define NB_BSDF 1
#define NB_LIGHT 1vec3 roomCubeMin = vec3(-10.0, -10.0, -10.0);
vec3 roomCubeMax = vec3(10.0, 10.0, 10.0);
vec3 wallCubeMax = vec3(10.0, 5.0, 1.0);
vec3 wallCubeMin = vec3(0.0, -10.0, -1.0);
vec3 sphereCenter = vec3(-3.0, -7.0, -3.0);
float sphereRadius = 3.0;
vec3 light = vec3(6.0, 8.0, 6.0);
float lightIntensity = 1.0;
float infinity = 10000.0;
float epsilon = 0.00001;
float lightSize = 0.2;
float pi = 3.14159265359;
float maxBounces = 100.0;
vec3 ReSTIR_lightEmission = vec3(0.5); // Light intensity/colorfloat random(vec3 scale, float seed) {
    return fract(sin(dot(gl_FragCoord.xyz + seed, scale)) * 43758.5453 + seed);
}

float hashCoords(vec2 p) {
    return fract(sin(dot(p, vec2(127.1, 311.7))) * 43758.5453);
}

float hashValue(float p) {
    return fract(sin(p * 43758.5453) * 43758.5453);
}

float rand(vec2 co, float seed) {
    return fract(sin(dot(co.xy + seed, vec2(12.9898, 78.233))) * 43758.5453);
}

vec3 uniformlyRandomDirection(float seed) {
    float u = random(vec3(12.9898, 78.233, 151.7182), seed);
    float v = random(vec3(63.7264, 10.873, 623.6736), seed);
    float z = 1.0 - 2.0 * u;
    float r = sqrt(1.0 - z * z);
    float angle = 6.283185307179586 * v;
    return vec3(r * cos(angle), r * sin(angle), z);
}

vec3 uniformlyRandomVector(float seed) {
    return uniformlyRandomDirection(seed) * sqrt(random(vec3(36.7539, 50.3658, 306.2759), seed));
}

// https://rh8liuqy.github.io/Uniform_Disk.html
vec2 uniformlyRandomDisk(float seed, int radius) {
    float u = random(vec3(12.9898, 78.233, 151.7182), seed);
    float v = random(vec3(63.7264, 10.873, 623.6736), seed + 1.0);
    float x = float(radius) * sqrt(u) * cos(2.0 * pi * u);
    float y = float(radius) * sqrt(v) * sin(2.0 * pi * v);
    return vec2(x, y);
}float intersectSphere(vec3 origin, vec3 ray, vec3 sphereCenter, float sphereRadius) {
    vec3 toSphere = origin - sphereCenter;
    float a = dot(ray, ray);
    float b = 2.0 * dot(toSphere, ray);
    float c = dot(toSphere, toSphere) - sphereRadius*sphereRadius;
    float discriminant = b*b - 4.0*a*c;
    if(discriminant > 0.0) {
        float t = (-b - sqrt(discriminant)) / (2.0 * a);
        if(t > 0.0) return t;
    }
    return infinity;
}

vec3 normalForSphere(vec3 hit, vec3 sphereCenter, float sphereRadius) {
    return (hit - sphereCenter) / sphereRadius;
}vec2 intersectCube(vec3 origin, vec3 ray, vec3 cubeMin, vec3 cubeMax) {
    vec3 tMin = (cubeMin - origin) / ray;
    vec3 tMax = (cubeMax - origin) / ray;
    vec3 t1 = min(tMin, tMax);
    vec3 t2 = max(tMin, tMax);
    float tNear = max(max(t1.x, t1.y), t1.z);
    float tFar = min(min(t2.x, t2.y), t2.z);
    return vec2(tNear, tFar);
}

vec3 normalForCube(vec3 hit, vec3 cubeMin, vec3 cubeMax) {
    if (hit.x < cubeMin.x + epsilon)
    return vec3(-1.0, 0.0, 0.0);
    else if (hit.x > cubeMax.x - epsilon)
    return vec3(1.0, 0.0, 0.0);
    else if (hit.y < cubeMin.y + epsilon)
    return vec3(0.0, -1.0, 0.0);
    else if (hit.y > cubeMax.y - epsilon)
    return vec3(0.0, 1.0, 0.0);
    else if (hit.z < cubeMin.z + epsilon)
    return vec3(0.0, 0.0, -1.0);
    else
    return vec3(0.0, 0.0, 1.0);
}struct Isect {
    float t; // Distance along the ray
    vec3 position;
    vec3 normal;
    vec3 albedo; // Simplified material color
    bool isLight; // Is the hit surface a light source?
    // vec3 emission; // Light emission color
    float pdf; // PDF of sampling this hit (e.g., light sampling PDF)
};

Isect intersect(vec3 ray, vec3 origin) {
    Isect isect;
    vec2 tRoom = intersectCube(origin, ray, roomCubeMin, roomCubeMax);
    float tSphere = intersectSphere(origin, ray, sphereCenter, sphereRadius);
    float tLight = intersectSphere(origin, ray, light, lightSize);
    vec2 tWall = intersectCube(origin, ray, wallCubeMin, wallCubeMax);
    float t = infinity;
    if (tRoom.x < tRoom.y) t = tRoom.y;
    if (tWall.x < tWall.y && tWall.x > epsilon && tWall.x < t) t = tWall.x;
    if (tSphere < t) t = tSphere;
    if (tLight < t) t = tLight;

    isect.t = t;
    isect.albedo = vec3(1.0);
    isect.position = origin + ray * t;
    // float specularHighlight = 0.0;

    if (t == infinity) {
        return isect;
    }

    if (t == tRoom.y) {
        isect.normal = -normalForCube(isect.position, roomCubeMin, roomCubeMax);
        if(isect.position.x < -9.9999) isect.albedo = vec3(0.1, 0.5, 1.0);
        else if(isect.position.x > 9.9999) isect.albedo = vec3(1.0, 0.9, 0.1);
    }  else if (t == tWall.x) {
        isect.normal = normalForCube(isect.position, wallCubeMin, wallCubeMax);
        isect.albedo = vec3(1.0); // Wall color
    } else if (t == tSphere) {
        isect.normal = normalForSphere(isect.position, sphereCenter, sphereRadius);
    } else if (t == tLight) {
        isect.normal = normalForSphere(isect.position, light, lightSize);
        isect.isLight = true;
    }
    return isect;
}vec3 cosineWeightedDirection(float seed, vec3 normal) {
    // Simple cosine-weighted random direction
    float u = random(vec3(12.9898, 78.233, 151.7182), seed);
    float v = random(vec3(63.7264, 10.873, 623.6736), seed);
    float r = sqrt(u);
    float angle = 6.28318530718 * v;
    vec3 sdir, tdir;
    if (abs(normal.x) < .5) {
        sdir = cross(normal, vec3(1,0,0));
    } else {
        sdir = cross(normal, vec3(0,1,0));
    }
    tdir = cross(normal, sdir);
    return normalize(r*cos(angle)*sdir + r*sin(angle)*tdir + sqrt(1.-u)*normal);
}

vec3 uniformSpherePos(vec3 origin, float seed, vec3 center, float radius) {
    float u = random(vec3(12.9898, 78.233, 151.7182), seed);
    float v = random(vec3(63.7264, 10.873, 623.6736), seed);
    float theta = 2.0 * pi * u;
    float phi = acos(2.0 * v - 1.0);
    vec3 lightPoint = center + radius * vec3(cos(theta) * sin(phi), sin(theta) * sin(phi), cos(phi));
    return lightPoint;
}

vec3 uniformSphereDirection(vec3 origin, float seed, vec3 center, float radius) {
    vec3 lightPoint = uniformSpherePos(origin, seed, center, radius);
    return normalize(lightPoint - origin);
}

float pdfCosineWeighted(vec3 direction, vec3 normal) {
    float cosTheta = dot(direction, normal);
    if (cosTheta <= 0.0) return epsilon;
    return cosTheta / pi;
}

float pdfUniformSphere(vec3 direction, vec3 origin) {
    Isect isect = intersect(direction, origin);
    if (isect.isLight) {
        vec3 fromLightDir = -direction;
        float dist2 = dot(fromLightDir, fromLightDir);
        fromLightDir = normalize(fromLightDir);
        vec3 lightNormal = normalize(isect.position - light);
        float cosAtLight = max(0.0, dot(lightNormal, fromLightDir));
        if (cosAtLight < epsilon || dist2 < epsilon) return epsilon;
        float surfaceArea = 4.0 * pi * lightSize * lightSize;
        // Conversion factor from area to solid angle pdf is cos(theta)/dist2 and you divide by conversion factor
        float pArea = (1.0 / surfaceArea) * (dist2 / cosAtLight);
        return pArea;
    }
    return epsilon;
}

float shadow(vec3 origin, vec3 ray, vec3 sphereCenter, float sphereRadius) {
    float t = intersectSphere(origin, ray, sphereCenter, sphereRadius);
    if (t < 1.0) return 0.0;
    return 1.0;
}

float balanceHeuristic(float pdf_a, float nb_pdf_a, float pdf_b, float nb_pdf_b) {
    return pdf_a / (nb_pdf_a * pdf_a + nb_pdf_b * pdf_b + epsilon);
}
float evaluate_target_function_at_center(vec3 light_sample, Isect isect, vec3 brdf) {
    vec3 sample_direction = normalize(light_sample - isect.position);
    Isect light_isect = intersect(sample_direction, isect.position);
    float visibility = light_isect.isLight ? 1.0 : 0.0;
    float ndotr = dot(isect.normal, sample_direction);
    vec3 contribution = brdf * abs(ndotr) * visibility;
    return dot(contribution, vec3(0.3086, 0.6094, 0.0820));
}
struct ReSTIR_Reservoir {
    vec3 Y;      // light direction or position
    float W_Y;   // selected sample weight
    float p_hat;
    float w_sum; // total weight of all candidates
    float c;    //sample count
    float t; //geometry info
};

ReSTIR_Reservoir initializeReservoir() {
    ReSTIR_Reservoir r;
    r.Y = vec3(0.0);
    r.W_Y = 0.0;
    r.w_sum = 0.0;

    return r;
}

ReSTIR_Reservoir unpackReservoir(vec4 data1, vec4 data2) {
    ReSTIR_Reservoir r;
    r.Y = data1.rgb;        // using .rgb for vec3
    r.p_hat = data1.a;
    r.W_Y = data2.r;
    r.w_sum = data2.g;
    r.t = data2.b;
    r.c = data2.a;
    return r;
}

vec4 packReservoir1(ReSTIR_Reservoir r) {
    return vec4(r.Y, r.p_hat);
}

vec4 packReservoir2(ReSTIR_Reservoir r) {
    return vec4(r.W_Y, r.w_sum, r.t, r.c); // zero pad unused values
}
struct ReSTIRGI_Reservoir {
    vec3 Y;      // sample position (x2)
    float W_Y;   // selected sample weight
    vec3 L;     // indirect light contribution
    float c;    //sample count
};

ReSTIRGI_Reservoir initializeReservoirGI() {
    ReSTIRGI_Reservoir r;
    r.Y = vec3(0.0);
    r.W_Y = 0.0;
    r.L = vec3(0.0);
    r.c = 0.0;

    return r;
}

ReSTIRGI_Reservoir unpackReservoirGI(vec4 data1, vec4 data2) {
    ReSTIRGI_Reservoir r;
    r.Y = data1.rgb;        // using .rgb for vec3
    r.W_Y = data1.a;
    r.L = data2.rgb;        // using .rgb for vec3
    r.c = data2.a;
    return r;
}

vec4 packReservoirGI1(ReSTIRGI_Reservoir r) {
    return vec4(r.Y, r.W_Y);
}

vec4 packReservoirGI2(ReSTIRGI_Reservoir r) {
    return vec4(r.L, r.c); // zero pad unused values
}

ReSTIR_Reservoir reservoirGIToDI(ReSTIRGI_Reservoir r_in) {
    ReSTIR_Reservoir r;
    r.Y = r_in.Y;
    r.W_Y = r_in.W_Y;
    r.p_hat = dot(r_in.L, vec3(0.3086, 0.6094, 0.0820));
    r.w_sum = 0.0; // w_sum is not used in GI
    r.t = 0.0; // t is not used in GI
    r.c = r.c; // c is the sample count
    return r;
}

float luminance(vec3 contrib) {
    return dot(contrib, vec3(0.3086, 0.6094, 0.0820));
}
ReSTIR_Reservoir sample_lights_restir_spatial(vec3 ray, float seed, Isect isectCenter, sampler2D reservoirData1, sampler2D reservoirData2) {
    vec2 uv = gl_FragCoord.xy / uRes;
    ReSTIR_Reservoir rCenter = unpackReservoir(texture(reservoirData1, uv), texture(reservoirData2, uv));
    ReSTIR_Reservoir r = initializeReservoir();
    int MAX_NEIGHBORS = 16;
    ReSTIR_Reservoir candidates[17];
    candidates[0] = rCenter;
    int count = 1;
    float sum_p_hat = rCenter.p_hat;
    vec3 centerBrdf = isectCenter.albedo / pi;
    for (int candidateIndex = 0; candidateIndex < MAX_NEIGHBORS; candidateIndex++) {
        vec2 dxy = uniformlyRandomDisk(hashValue(seed + float(candidateIndex)), 8);
        vec2 neighbor = gl_FragCoord.xy + vec2(int(dxy.x), int(dxy.y));
        if (neighbor.x < 0.0 || neighbor.y < 0.0 ||
        neighbor.x >= uRes.x || neighbor.y >= uRes.y) continue;

        vec2 uv = (neighbor) / uRes;

        vec4 uCandidate1 = texture(reservoirData1, uv);
        vec4 uCandidate2 = texture(reservoirData2, uv);

        candidates[count] = unpackReservoir(uCandidate1, uCandidate2);
        vec2 percent = (neighbor / uRes);
        vec3 candidateRay = normalize(mix(mix(uRay00, uRay01, percent.y), mix(uRay10, uRay11, percent.y), percent.x));
        Isect candidateIsect = intersect(candidateRay, uEye);

        if (
            dot(candidateIsect.normal, isectCenter.normal) < 0.95 ||
            abs(candidateIsect.t - isectCenter.t) / isectCenter.t > 0.3 ||
            abs(candidateIsect.t - isectCenter.t) / isectCenter.t < 0.1)
        continue;

        // generate X_i
        sum_p_hat += candidates[count].p_hat;
        r.c += candidates[count].c;
        count++;
    }
    if (sum_p_hat <= epsilon) return r;
    for (int i = 0; i < MAX_NEIGHBORS + 1; i++) {
        if (i >= count) break;
        ReSTIR_Reservoir r_i = candidates[i];
        float m_i = r_i.p_hat/sum_p_hat;
        float p_hat_at_center = evaluate_target_function_at_center(r_i.Y, isectCenter, centerBrdf);
        float w_i = m_i * p_hat_at_center * r_i.W_Y;
        float randint = random(vec3(71.31, 67.73, 91.83), hashValue(seed + float(i)));
        r.w_sum += w_i;
        if (randint < w_i / r.w_sum) {
            r.Y = r_i.Y;
            r.p_hat = p_hat_at_center;
        }
    }
    if (r.w_sum == 0.0 || r.p_hat <= epsilon) {
        return r;
    }
    r.W_Y = r.w_sum / r.p_hat;
    return r;
}ReSTIR_Reservoir sample_lights_ris(ReSTIR_Reservoir r_in, Isect isect, vec3 ray, int nb_bsdf, int nb_light, float seed) {
    ReSTIR_Reservoir r = r_in;
    int M = nb_bsdf + nb_light;
    vec3 nextOrigin = isect.position + isect.normal * epsilon;
    float baseSeed = hashValue(float(M) * 23.0 + 79.0) + seed;

    for (int candidate = 0; candidate < M; candidate++) {
        vec3 next_ray = ray;
        vec3 light_sample;
        float cBaseSeed = baseSeed * 17.51 + hashValue(float(candidate)) * 119.73;

        float reservoirWeight = 0.0;
        bool usedCosine = candidate < NB_BSDF;
        if (usedCosine) {
            next_ray = cosineWeightedDirection(cBaseSeed + 11.37, isect.normal);
            // is bsdf so need to check if ray ends at light
            Isect next_isect = intersect(next_ray, nextOrigin);
            if (!next_isect.isLight) {
                continue;
            }
            light_sample = next_isect.position;
        } else {
            light_sample = uniformSpherePos(isect.position, cBaseSeed + 23.57, light, lightSize);
            next_ray = normalize(light_sample - isect.position);
        }

        float pdfCosine = pdfCosineWeighted(next_ray, isect.normal);
        float pdfLight = pdfUniformSphere(next_ray, isect.position);

        float pdfA = usedCosine? pdfCosine : pdfLight;
        float pdfB = usedCosine? pdfLight : pdfCosine;
        float nbPdfA = float(usedCosine ? NB_BSDF : NB_LIGHT);
        float nbPdfB = float(usedCosine ? NB_LIGHT : NB_BSDF);
        float misWeight = balanceHeuristic(pdfA, nbPdfA, pdfB, nbPdfB);

        float pdfX = max(epsilon, usedCosine ? pdfCosine : pdfLight);

        vec3 brdf = isect.albedo / pi;
        float ndotr = dot(isect.normal, next_ray);
        float pHat = evaluate_target_function_at_center(light_sample, isect, brdf);

        if (ndotr <= epsilon || pHat <= epsilon || pdfX <= epsilon) {
            continue;
        }

        reservoirWeight = misWeight * pHat / pdfX;
        r.w_sum += reservoirWeight;
        float reservoirStrategy = random(vec3(1.0), cBaseSeed + 7.23);
        if (reservoirStrategy < reservoirWeight / r.w_sum) {
            r.p_hat = pHat;
            r.Y = light_sample;
            r.t = isect.t;
        }
    }

    if (r.w_sum > 0.0) {
        r.W_Y = r.w_sum / max(r.p_hat, epsilon);
    }
    r.c = 1.0;
    return r;
}

vec4 calculateColor(vec3 origin, vec3 ray, vec3 light) {
    vec3 colorMask = vec3(1.0);
    vec3 accumulatedColor = vec3(0.0);
    vec3 directLight = vec3(0.0);

    float timeEntropy = hashValue(uTime);
    float seed = hashCoords(gl_FragCoord.xy + timeEntropy * vec2(1.0, -1.0));
    vec2 uv = gl_FragCoord.xy / uRes;
    ReSTIR_Reservoir r = initializeReservoir();
    float russian_roulette_prob = 1.0;
    for (int bounce = 0; bounce < 1; bounce++) {
        float roulette = random(vec3(36.7539, 50.3658, 306.2759), dot(gl_FragCoord.xy, vec2(12.9898, 78.233)) + uTime * 17.13 + float(bounce) * 91.71);
        if (roulette >= russian_roulette_prob) {
            break;
        }
        colorMask /= russian_roulette_prob;

        Isect isect = intersect(ray, origin);
        if (isect.t == infinity) {
            break;
        }

        vec3 nextOrigin = isect.position + isect.normal * epsilon;
        float baseSeed = hashValue(float(bounce) * 51.19 + 79.0) + seed;

        if(bounce == 0) {
            r = sample_lights_restir_spatial(ray, baseSeed, isect, uReservoirData1, uReservoirData2);
            // return vec4(vec3(r.c), 1.0);
            r.c = min(512.0, r.c);
        } else {
            r = initializeReservoir();
            r = sample_lights_ris(r, isect, ray, NB_BSDF, NB_LIGHT, baseSeed);
        }

        if (isect.isLight && bounce == 0) {
            accumulatedColor += lightIntensity;
        }

        if (r.w_sum > 0.0) {
            vec3 brdf = isect.albedo / pi;
            vec3 sample_direction = normalize(r.Y - isect.position);
            float ndotr = dot(isect.normal, sample_direction);
            directLight = lightIntensity * brdf * abs(ndotr) * r.W_Y;
            accumulatedColor += colorMask * directLight;
        }

        vec3 nextRay = cosineWeightedDirection(baseSeed, isect.normal);
        float pdfCosine = pdfCosineWeighted(nextRay, isect.normal);
        float ndotr = dot(isect.normal, nextRay);
        if (ndotr <= 0.0 || pdfCosine <= epsilon) break;
        vec3 brdf = isect.albedo / pi;
        colorMask *= brdf * ndotr / pdfCosine;

        // Russian Roulette Termination
        float throughput_max_element = max(max(colorMask.x, colorMask.y), colorMask.z);
        russian_roulette_prob = min(throughput_max_element, 1.0);
        origin = nextOrigin;
        ray = nextRay;
    }

    return vec4(accumulatedColor, 1.0);
}

void main() {
    vec4 color = calculateColor(uEye, initialRay, light);
    fragColor = color;
}
`;

export const ReSTIR_temporalPassFSText = 
`#version 300 es
precision highp float;

uniform vec3 uEye, uRay00, uRay01, uRay10, uRay11;
uniform vec2 uRes;
uniform float uTime;
uniform mat4 uViewMatPrev;
uniform mat4 uProjMatPrev;
in vec3 initialRay;

// previous state data
uniform sampler2D uReservoirData1;
uniform sampler2D uReservoirData2;

layout(location = 0) out vec4 out_ReservoirData1;
layout(location = 1) out vec4 out_ReservoirData2;

#define NB_BSDF 1
#define NB_LIGHT 1vec3 roomCubeMin = vec3(-10.0, -10.0, -10.0);
vec3 roomCubeMax = vec3(10.0, 10.0, 10.0);
vec3 wallCubeMax = vec3(10.0, 5.0, 1.0);
vec3 wallCubeMin = vec3(0.0, -10.0, -1.0);
vec3 sphereCenter = vec3(-3.0, -7.0, -3.0);
float sphereRadius = 3.0;
vec3 light = vec3(6.0, 8.0, 6.0);
float lightIntensity = 1.0;
float infinity = 10000.0;
float epsilon = 0.00001;
float lightSize = 0.2;
float pi = 3.14159265359;
float maxBounces = 100.0;
vec3 ReSTIR_lightEmission = vec3(0.5); // Light intensity/colorfloat intersectSphere(vec3 origin, vec3 ray, vec3 sphereCenter, float sphereRadius) {
    vec3 toSphere = origin - sphereCenter;
    float a = dot(ray, ray);
    float b = 2.0 * dot(toSphere, ray);
    float c = dot(toSphere, toSphere) - sphereRadius*sphereRadius;
    float discriminant = b*b - 4.0*a*c;
    if(discriminant > 0.0) {
        float t = (-b - sqrt(discriminant)) / (2.0 * a);
        if(t > 0.0) return t;
    }
    return infinity;
}

vec3 normalForSphere(vec3 hit, vec3 sphereCenter, float sphereRadius) {
    return (hit - sphereCenter) / sphereRadius;
}vec2 intersectCube(vec3 origin, vec3 ray, vec3 cubeMin, vec3 cubeMax) {
    vec3 tMin = (cubeMin - origin) / ray;
    vec3 tMax = (cubeMax - origin) / ray;
    vec3 t1 = min(tMin, tMax);
    vec3 t2 = max(tMin, tMax);
    float tNear = max(max(t1.x, t1.y), t1.z);
    float tFar = min(min(t2.x, t2.y), t2.z);
    return vec2(tNear, tFar);
}

vec3 normalForCube(vec3 hit, vec3 cubeMin, vec3 cubeMax) {
    if (hit.x < cubeMin.x + epsilon)
    return vec3(-1.0, 0.0, 0.0);
    else if (hit.x > cubeMax.x - epsilon)
    return vec3(1.0, 0.0, 0.0);
    else if (hit.y < cubeMin.y + epsilon)
    return vec3(0.0, -1.0, 0.0);
    else if (hit.y > cubeMax.y - epsilon)
    return vec3(0.0, 1.0, 0.0);
    else if (hit.z < cubeMin.z + epsilon)
    return vec3(0.0, 0.0, -1.0);
    else
    return vec3(0.0, 0.0, 1.0);
}struct Isect {
    float t; // Distance along the ray
    vec3 position;
    vec3 normal;
    vec3 albedo; // Simplified material color
    bool isLight; // Is the hit surface a light source?
    // vec3 emission; // Light emission color
    float pdf; // PDF of sampling this hit (e.g., light sampling PDF)
};

Isect intersect(vec3 ray, vec3 origin) {
    Isect isect;
    vec2 tRoom = intersectCube(origin, ray, roomCubeMin, roomCubeMax);
    float tSphere = intersectSphere(origin, ray, sphereCenter, sphereRadius);
    float tLight = intersectSphere(origin, ray, light, lightSize);
    vec2 tWall = intersectCube(origin, ray, wallCubeMin, wallCubeMax);
    float t = infinity;
    if (tRoom.x < tRoom.y) t = tRoom.y;
    if (tWall.x < tWall.y && tWall.x > epsilon && tWall.x < t) t = tWall.x;
    if (tSphere < t) t = tSphere;
    if (tLight < t) t = tLight;

    isect.t = t;
    isect.albedo = vec3(1.0);
    isect.position = origin + ray * t;
    // float specularHighlight = 0.0;

    if (t == infinity) {
        return isect;
    }

    if (t == tRoom.y) {
        isect.normal = -normalForCube(isect.position, roomCubeMin, roomCubeMax);
        if(isect.position.x < -9.9999) isect.albedo = vec3(0.1, 0.5, 1.0);
        else if(isect.position.x > 9.9999) isect.albedo = vec3(1.0, 0.9, 0.1);
    }  else if (t == tWall.x) {
        isect.normal = normalForCube(isect.position, wallCubeMin, wallCubeMax);
        isect.albedo = vec3(1.0); // Wall color
    } else if (t == tSphere) {
        isect.normal = normalForSphere(isect.position, sphereCenter, sphereRadius);
    } else if (t == tLight) {
        isect.normal = normalForSphere(isect.position, light, lightSize);
        isect.isLight = true;
    }
    return isect;
}
struct ReSTIR_Reservoir {
    vec3 Y;      // light direction or position
    float W_Y;   // selected sample weight
    float p_hat;
    float w_sum; // total weight of all candidates
    float c;    //sample count
    float t; //geometry info
};

ReSTIR_Reservoir initializeReservoir() {
    ReSTIR_Reservoir r;
    r.Y = vec3(0.0);
    r.W_Y = 0.0;
    r.w_sum = 0.0;

    return r;
}

ReSTIR_Reservoir unpackReservoir(vec4 data1, vec4 data2) {
    ReSTIR_Reservoir r;
    r.Y = data1.rgb;        // using .rgb for vec3
    r.p_hat = data1.a;
    r.W_Y = data2.r;
    r.w_sum = data2.g;
    r.t = data2.b;
    r.c = data2.a;
    return r;
}

vec4 packReservoir1(ReSTIR_Reservoir r) {
    return vec4(r.Y, r.p_hat);
}

vec4 packReservoir2(ReSTIR_Reservoir r) {
    return vec4(r.W_Y, r.w_sum, r.t, r.c); // zero pad unused values
}
struct ReSTIRGI_Reservoir {
    vec3 Y;      // sample position (x2)
    float W_Y;   // selected sample weight
    vec3 L;     // indirect light contribution
    float c;    //sample count
};

ReSTIRGI_Reservoir initializeReservoirGI() {
    ReSTIRGI_Reservoir r;
    r.Y = vec3(0.0);
    r.W_Y = 0.0;
    r.L = vec3(0.0);
    r.c = 0.0;

    return r;
}

ReSTIRGI_Reservoir unpackReservoirGI(vec4 data1, vec4 data2) {
    ReSTIRGI_Reservoir r;
    r.Y = data1.rgb;        // using .rgb for vec3
    r.W_Y = data1.a;
    r.L = data2.rgb;        // using .rgb for vec3
    r.c = data2.a;
    return r;
}

vec4 packReservoirGI1(ReSTIRGI_Reservoir r) {
    return vec4(r.Y, r.W_Y);
}

vec4 packReservoirGI2(ReSTIRGI_Reservoir r) {
    return vec4(r.L, r.c); // zero pad unused values
}

ReSTIR_Reservoir reservoirGIToDI(ReSTIRGI_Reservoir r_in) {
    ReSTIR_Reservoir r;
    r.Y = r_in.Y;
    r.W_Y = r_in.W_Y;
    r.p_hat = dot(r_in.L, vec3(0.3086, 0.6094, 0.0820));
    r.w_sum = 0.0; // w_sum is not used in GI
    r.t = 0.0; // t is not used in GI
    r.c = r.c; // c is the sample count
    return r;
}

float luminance(vec3 contrib) {
    return dot(contrib, vec3(0.3086, 0.6094, 0.0820));
}float random(vec3 scale, float seed) {
    return fract(sin(dot(gl_FragCoord.xyz + seed, scale)) * 43758.5453 + seed);
}

float hashCoords(vec2 p) {
    return fract(sin(dot(p, vec2(127.1, 311.7))) * 43758.5453);
}

float hashValue(float p) {
    return fract(sin(p * 43758.5453) * 43758.5453);
}

float rand(vec2 co, float seed) {
    return fract(sin(dot(co.xy + seed, vec2(12.9898, 78.233))) * 43758.5453);
}

vec3 uniformlyRandomDirection(float seed) {
    float u = random(vec3(12.9898, 78.233, 151.7182), seed);
    float v = random(vec3(63.7264, 10.873, 623.6736), seed);
    float z = 1.0 - 2.0 * u;
    float r = sqrt(1.0 - z * z);
    float angle = 6.283185307179586 * v;
    return vec3(r * cos(angle), r * sin(angle), z);
}

vec3 uniformlyRandomVector(float seed) {
    return uniformlyRandomDirection(seed) * sqrt(random(vec3(36.7539, 50.3658, 306.2759), seed));
}

// https://rh8liuqy.github.io/Uniform_Disk.html
vec2 uniformlyRandomDisk(float seed, int radius) {
    float u = random(vec3(12.9898, 78.233, 151.7182), seed);
    float v = random(vec3(63.7264, 10.873, 623.6736), seed + 1.0);
    float x = float(radius) * sqrt(u) * cos(2.0 * pi * u);
    float y = float(radius) * sqrt(v) * sin(2.0 * pi * v);
    return vec2(x, y);
}vec3 cosineWeightedDirection(float seed, vec3 normal) {
    // Simple cosine-weighted random direction
    float u = random(vec3(12.9898, 78.233, 151.7182), seed);
    float v = random(vec3(63.7264, 10.873, 623.6736), seed);
    float r = sqrt(u);
    float angle = 6.28318530718 * v;
    vec3 sdir, tdir;
    if (abs(normal.x) < .5) {
        sdir = cross(normal, vec3(1,0,0));
    } else {
        sdir = cross(normal, vec3(0,1,0));
    }
    tdir = cross(normal, sdir);
    return normalize(r*cos(angle)*sdir + r*sin(angle)*tdir + sqrt(1.-u)*normal);
}

vec3 uniformSpherePos(vec3 origin, float seed, vec3 center, float radius) {
    float u = random(vec3(12.9898, 78.233, 151.7182), seed);
    float v = random(vec3(63.7264, 10.873, 623.6736), seed);
    float theta = 2.0 * pi * u;
    float phi = acos(2.0 * v - 1.0);
    vec3 lightPoint = center + radius * vec3(cos(theta) * sin(phi), sin(theta) * sin(phi), cos(phi));
    return lightPoint;
}

vec3 uniformSphereDirection(vec3 origin, float seed, vec3 center, float radius) {
    vec3 lightPoint = uniformSpherePos(origin, seed, center, radius);
    return normalize(lightPoint - origin);
}

float pdfCosineWeighted(vec3 direction, vec3 normal) {
    float cosTheta = dot(direction, normal);
    if (cosTheta <= 0.0) return epsilon;
    return cosTheta / pi;
}

float pdfUniformSphere(vec3 direction, vec3 origin) {
    Isect isect = intersect(direction, origin);
    if (isect.isLight) {
        vec3 fromLightDir = -direction;
        float dist2 = dot(fromLightDir, fromLightDir);
        fromLightDir = normalize(fromLightDir);
        vec3 lightNormal = normalize(isect.position - light);
        float cosAtLight = max(0.0, dot(lightNormal, fromLightDir));
        if (cosAtLight < epsilon || dist2 < epsilon) return epsilon;
        float surfaceArea = 4.0 * pi * lightSize * lightSize;
        // Conversion factor from area to solid angle pdf is cos(theta)/dist2 and you divide by conversion factor
        float pArea = (1.0 / surfaceArea) * (dist2 / cosAtLight);
        return pArea;
    }
    return epsilon;
}

float shadow(vec3 origin, vec3 ray, vec3 sphereCenter, float sphereRadius) {
    float t = intersectSphere(origin, ray, sphereCenter, sphereRadius);
    if (t < 1.0) return 0.0;
    return 1.0;
}

float balanceHeuristic(float pdf_a, float nb_pdf_a, float pdf_b, float nb_pdf_b) {
    return pdf_a / (nb_pdf_a * pdf_a + nb_pdf_b * pdf_b + epsilon);
}
float evaluate_target_function_at_center(vec3 light_sample, Isect isect, vec3 brdf) {
    vec3 sample_direction = normalize(light_sample - isect.position);
    Isect light_isect = intersect(sample_direction, isect.position);
    float visibility = light_isect.isLight ? 1.0 : 0.0;
    float ndotr = dot(isect.normal, sample_direction);
    vec3 contribution = brdf * abs(ndotr) * visibility;
    return dot(contribution, vec3(0.3086, 0.6094, 0.0820));
}vec2 getPrevUV(Isect isect) {
    vec4 pWorld = vec4(isect.position, 1.0);
    vec4 clip_prev = uProjMatPrev * uViewMatPrev * pWorld;
    if (clip_prev.w < epsilon) {
        return vec2(-1.0); // invalid UV
    }
    vec3 ndc_prev = clip_prev.xyz / clip_prev.w;
    return ndc_prev.xy * 0.5 + 0.5; // convert to [0, 1] range
}


ReSTIR_Reservoir getTemporalNeighborFromTexture(Isect isectCenter, sampler2D reservoirData1, sampler2D reservoirData2) {
    ReSTIR_Reservoir r = initializeReservoir();
    vec2 uv_prev = getPrevUV(isectCenter);
    if (uv_prev.x < 0.0 || uv_prev.x >= 1.0 || uv_prev.y < 0.0 || uv_prev.y >= 1.0) {
        return r;
    }

    // fetch temporal neighbor
    vec4 uReservoirData1Vec = texture(reservoirData1, uv_prev);
    vec4 uReservoirData2Vec = texture(reservoirData2, uv_prev);
    ReSTIR_Reservoir r_prev = unpackReservoir(uReservoirData1Vec, uReservoirData2Vec);

    if (r_prev.W_Y < epsilon) {
        return r;
    }

    return r_prev;
}

ReSTIRGI_Reservoir getTemporalNeighborFromTextureGI(Isect isectCenter, sampler2D reservoirData1, sampler2D reservoirData2) {
    ReSTIRGI_Reservoir r = initializeReservoirGI();
    vec2 uv_prev = getPrevUV(isectCenter);
    if (uv_prev.x < 0.0 || uv_prev.x >= 1.0 || uv_prev.y < 0.0 || uv_prev.y >= 1.0) {
        return r;
    }

    // fetch temporal neighbor
    vec4 uReservoirData1Vec = texture(reservoirData1, uv_prev);
    vec4 uReservoirData2Vec = texture(reservoirData2, uv_prev);
    ReSTIRGI_Reservoir r_prev = unpackReservoirGI(uReservoirData1Vec, uReservoirData2Vec);

    if (r_prev.W_Y < epsilon) {
        return r;
    }

    return r_prev;
}

ReSTIR_Reservoir resample_temporal_base(ReSTIR_Reservoir r_current, ReSTIR_Reservoir r_prev, Isect isectCenter, float seed, bool use_p_hat, out bool acceptCurrent) {
    ReSTIR_Reservoir r_out = initializeReservoir();
    float misWeight;
    float reservoirWeight;
    float reservoirStrategy;
    vec3 centerBrdf = isectCenter.albedo / pi;
    float neighborTargetFunctionAtCenter = use_p_hat ? r_prev.p_hat : evaluate_target_function_at_center(r_prev.Y, isectCenter, centerBrdf);
    float centerTargetFunctionAtCenter = r_current.p_hat;

    ReSTIR_Reservoir[2] reservoirs = ReSTIR_Reservoir[2](r_prev, r_current);
    float[2] targetFunctions = float[2](neighborTargetFunctionAtCenter, centerTargetFunctionAtCenter);
    acceptCurrent = false;
    for (int i = 0; i < 2; i++) {
        if (targetFunctions[i] < epsilon) {
            continue;
        }
        // resample initial candidates
        misWeight = reservoirs[i].c * targetFunctions[i] / (r_prev.c * neighborTargetFunctionAtCenter + r_current.c * centerTargetFunctionAtCenter);
        reservoirWeight = misWeight * targetFunctions[i] * reservoirs[i].W_Y;
        r_out.w_sum += reservoirWeight;
        r_out.c += reservoirs[i].c;
        reservoirStrategy = random(vec3(67.71, 31.91, 83.17), seed + float(i));
        if (reservoirStrategy < reservoirWeight / r_out.w_sum) {
            r_out.p_hat = targetFunctions[i];
            r_out.Y = reservoirs[i].Y;
            r_out.t = reservoirs[i].t;
            acceptCurrent = i == 1; // accept the current reservoir if it's the second one (center)
        }
    }

    r_out.W_Y = r_out.w_sum / r_out.p_hat;
    return r_out;
}

ReSTIR_Reservoir resample_temporal(ReSTIR_Reservoir r_current, ReSTIR_Reservoir r_prev, Isect isectCenter, float seed) {
    bool acceptCurrent;
    return resample_temporal_base(r_current, r_prev, isectCenter, seed, false, acceptCurrent);
}

ReSTIRGI_Reservoir resample_temporalGI(ReSTIRGI_Reservoir r_current, ReSTIRGI_Reservoir r_prev, Isect isectCenter, float seed) {
    bool acceptCurrent;
    ReSTIRGI_Reservoir r_out_gi = initializeReservoirGI();
    ReSTIR_Reservoir r_out = resample_temporal_base(reservoirGIToDI(r_current), reservoirGIToDI(r_prev), isectCenter, seed, true, acceptCurrent);
    if (acceptCurrent) {
        r_out_gi = r_current;
    } else {
        r_out_gi = r_prev;
    }
    r_out_gi.W_Y = r_out.W_Y;
    return r_out_gi;
}ReSTIR_Reservoir sample_lights_ris(ReSTIR_Reservoir r_in, Isect isect, vec3 ray, int nb_bsdf, int nb_light, float seed) {
    ReSTIR_Reservoir r = r_in;
    int M = nb_bsdf + nb_light;
    vec3 nextOrigin = isect.position + isect.normal * epsilon;
    float baseSeed = hashValue(float(M) * 23.0 + 79.0) + seed;

    for (int candidate = 0; candidate < M; candidate++) {
        vec3 next_ray = ray;
        vec3 light_sample;
        float cBaseSeed = baseSeed * 17.51 + hashValue(float(candidate)) * 119.73;

        float reservoirWeight = 0.0;
        bool usedCosine = candidate < NB_BSDF;
        if (usedCosine) {
            next_ray = cosineWeightedDirection(cBaseSeed + 11.37, isect.normal);
            // is bsdf so need to check if ray ends at light
            Isect next_isect = intersect(next_ray, nextOrigin);
            if (!next_isect.isLight) {
                continue;
            }
            light_sample = next_isect.position;
        } else {
            light_sample = uniformSpherePos(isect.position, cBaseSeed + 23.57, light, lightSize);
            next_ray = normalize(light_sample - isect.position);
        }

        float pdfCosine = pdfCosineWeighted(next_ray, isect.normal);
        float pdfLight = pdfUniformSphere(next_ray, isect.position);

        float pdfA = usedCosine? pdfCosine : pdfLight;
        float pdfB = usedCosine? pdfLight : pdfCosine;
        float nbPdfA = float(usedCosine ? NB_BSDF : NB_LIGHT);
        float nbPdfB = float(usedCosine ? NB_LIGHT : NB_BSDF);
        float misWeight = balanceHeuristic(pdfA, nbPdfA, pdfB, nbPdfB);

        float pdfX = max(epsilon, usedCosine ? pdfCosine : pdfLight);

        vec3 brdf = isect.albedo / pi;
        float ndotr = dot(isect.normal, next_ray);
        float pHat = evaluate_target_function_at_center(light_sample, isect, brdf);

        if (ndotr <= epsilon || pHat <= epsilon || pdfX <= epsilon) {
            continue;
        }

        reservoirWeight = misWeight * pHat / pdfX;
        r.w_sum += reservoirWeight;
        float reservoirStrategy = random(vec3(1.0), cBaseSeed + 7.23);
        if (reservoirStrategy < reservoirWeight / r.w_sum) {
            r.p_hat = pHat;
            r.Y = light_sample;
            r.t = isect.t;
        }
    }

    if (r.w_sum > 0.0) {
        r.W_Y = r.w_sum / max(r.p_hat, epsilon);
    }
    r.c = 1.0;
    return r;
}
ReSTIR_Reservoir getTemporalNeighborDI(Isect isectCenter, ReSTIR_Reservoir r_current, sampler2D reservoirData1, sampler2D reservoirData2) {
    ReSTIR_Reservoir temporalNeighbor = getTemporalNeighborFromTexture(isectCenter, reservoirData1, reservoirData2);
    ReSTIR_Reservoir defaultReservoir = initializeReservoir();
    if (temporalNeighbor.W_Y < epsilon) {
        return defaultReservoir;
    }
    vec3 lightDir = normalize(temporalNeighbor.Y - isectCenter.position);
    vec3 rayOrigin = isectCenter.position + isectCenter.normal * epsilon;
    Isect visibilityCheck = intersect(lightDir, rayOrigin);

    // If we dont hit the light there is occlusion
    if (!visibilityCheck.isLight || abs(r_current.t - temporalNeighbor.t) > 0.1 * r_current.t) {
        return defaultReservoir;
    }
    return temporalNeighbor;
}

ReSTIR_Reservoir sampleLightsTemporalDI(vec3 ray, float seed, Isect isectCenter, sampler2D reservoirData1, sampler2D reservoirData2) {
    ReSTIR_Reservoir r_in = initializeReservoir();
    ReSTIR_Reservoir r_current = sample_lights_ris(r_in, isectCenter, ray, NB_BSDF, NB_LIGHT, seed);
    ReSTIR_Reservoir r_prev = getTemporalNeighborDI(isectCenter, r_current, reservoirData1, reservoirData2);

    if (r_prev.W_Y < epsilon) {
        return r_current;
    }

    ReSTIR_Reservoir r_out = resample_temporal(r_current, r_prev, isectCenter, seed);
    return r_out;
}

void main() {
    vec3 ray = normalize(initialRay);
    float timeEntropy = hashValue(uTime);
    float seed = hashCoords(gl_FragCoord.xy + timeEntropy * vec2(1.0, -1.0));

    Isect isect = intersect(ray, uEye);
    ReSTIR_Reservoir r = sampleLightsTemporalDI(ray, seed, isect, uReservoirData1, uReservoirData2);
    out_ReservoirData1 = packReservoir1(r);
    out_ReservoirData2 = packReservoir2(r);
}

`;

export const RISFSText = 
`#version 300 es
precision highp float;

uniform vec3 uEye;
uniform float uTime;
in vec3 initialRay;

uniform sampler2D uTexture;
uniform float uTextureWeight;
uniform vec2 uRes;

#define NB_BSDF 1
#define NB_LIGHT 1vec3 roomCubeMin = vec3(-10.0, -10.0, -10.0);
vec3 roomCubeMax = vec3(10.0, 10.0, 10.0);
vec3 wallCubeMax = vec3(10.0, 5.0, 1.0);
vec3 wallCubeMin = vec3(0.0, -10.0, -1.0);
vec3 sphereCenter = vec3(-3.0, -7.0, -3.0);
float sphereRadius = 3.0;
vec3 light = vec3(6.0, 8.0, 6.0);
float lightIntensity = 1.0;
float infinity = 10000.0;
float epsilon = 0.00001;
float lightSize = 0.2;
float pi = 3.14159265359;
float maxBounces = 100.0;
vec3 ReSTIR_lightEmission = vec3(0.5); // Light intensity/colorfloat random(vec3 scale, float seed) {
    return fract(sin(dot(gl_FragCoord.xyz + seed, scale)) * 43758.5453 + seed);
}

float hashCoords(vec2 p) {
    return fract(sin(dot(p, vec2(127.1, 311.7))) * 43758.5453);
}

float hashValue(float p) {
    return fract(sin(p * 43758.5453) * 43758.5453);
}

float rand(vec2 co, float seed) {
    return fract(sin(dot(co.xy + seed, vec2(12.9898, 78.233))) * 43758.5453);
}

vec3 uniformlyRandomDirection(float seed) {
    float u = random(vec3(12.9898, 78.233, 151.7182), seed);
    float v = random(vec3(63.7264, 10.873, 623.6736), seed);
    float z = 1.0 - 2.0 * u;
    float r = sqrt(1.0 - z * z);
    float angle = 6.283185307179586 * v;
    return vec3(r * cos(angle), r * sin(angle), z);
}

vec3 uniformlyRandomVector(float seed) {
    return uniformlyRandomDirection(seed) * sqrt(random(vec3(36.7539, 50.3658, 306.2759), seed));
}

// https://rh8liuqy.github.io/Uniform_Disk.html
vec2 uniformlyRandomDisk(float seed, int radius) {
    float u = random(vec3(12.9898, 78.233, 151.7182), seed);
    float v = random(vec3(63.7264, 10.873, 623.6736), seed + 1.0);
    float x = float(radius) * sqrt(u) * cos(2.0 * pi * u);
    float y = float(radius) * sqrt(v) * sin(2.0 * pi * v);
    return vec2(x, y);
}vec2 intersectCube(vec3 origin, vec3 ray, vec3 cubeMin, vec3 cubeMax) {
    vec3 tMin = (cubeMin - origin) / ray;
    vec3 tMax = (cubeMax - origin) / ray;
    vec3 t1 = min(tMin, tMax);
    vec3 t2 = max(tMin, tMax);
    float tNear = max(max(t1.x, t1.y), t1.z);
    float tFar = min(min(t2.x, t2.y), t2.z);
    return vec2(tNear, tFar);
}

vec3 normalForCube(vec3 hit, vec3 cubeMin, vec3 cubeMax) {
    if (hit.x < cubeMin.x + epsilon)
    return vec3(-1.0, 0.0, 0.0);
    else if (hit.x > cubeMax.x - epsilon)
    return vec3(1.0, 0.0, 0.0);
    else if (hit.y < cubeMin.y + epsilon)
    return vec3(0.0, -1.0, 0.0);
    else if (hit.y > cubeMax.y - epsilon)
    return vec3(0.0, 1.0, 0.0);
    else if (hit.z < cubeMin.z + epsilon)
    return vec3(0.0, 0.0, -1.0);
    else
    return vec3(0.0, 0.0, 1.0);
}float intersectSphere(vec3 origin, vec3 ray, vec3 sphereCenter, float sphereRadius) {
    vec3 toSphere = origin - sphereCenter;
    float a = dot(ray, ray);
    float b = 2.0 * dot(toSphere, ray);
    float c = dot(toSphere, toSphere) - sphereRadius*sphereRadius;
    float discriminant = b*b - 4.0*a*c;
    if(discriminant > 0.0) {
        float t = (-b - sqrt(discriminant)) / (2.0 * a);
        if(t > 0.0) return t;
    }
    return infinity;
}

vec3 normalForSphere(vec3 hit, vec3 sphereCenter, float sphereRadius) {
    return (hit - sphereCenter) / sphereRadius;
}struct Isect {
    float t; // Distance along the ray
    vec3 position;
    vec3 normal;
    vec3 albedo; // Simplified material color
    bool isLight; // Is the hit surface a light source?
    // vec3 emission; // Light emission color
    float pdf; // PDF of sampling this hit (e.g., light sampling PDF)
};

Isect intersect(vec3 ray, vec3 origin) {
    Isect isect;
    vec2 tRoom = intersectCube(origin, ray, roomCubeMin, roomCubeMax);
    float tSphere = intersectSphere(origin, ray, sphereCenter, sphereRadius);
    float tLight = intersectSphere(origin, ray, light, lightSize);
    vec2 tWall = intersectCube(origin, ray, wallCubeMin, wallCubeMax);
    float t = infinity;
    if (tRoom.x < tRoom.y) t = tRoom.y;
    if (tWall.x < tWall.y && tWall.x > epsilon && tWall.x < t) t = tWall.x;
    if (tSphere < t) t = tSphere;
    if (tLight < t) t = tLight;

    isect.t = t;
    isect.albedo = vec3(1.0);
    isect.position = origin + ray * t;
    // float specularHighlight = 0.0;

    if (t == infinity) {
        return isect;
    }

    if (t == tRoom.y) {
        isect.normal = -normalForCube(isect.position, roomCubeMin, roomCubeMax);
        if(isect.position.x < -9.9999) isect.albedo = vec3(0.1, 0.5, 1.0);
        else if(isect.position.x > 9.9999) isect.albedo = vec3(1.0, 0.9, 0.1);
    }  else if (t == tWall.x) {
        isect.normal = normalForCube(isect.position, wallCubeMin, wallCubeMax);
        isect.albedo = vec3(1.0); // Wall color
    } else if (t == tSphere) {
        isect.normal = normalForSphere(isect.position, sphereCenter, sphereRadius);
    } else if (t == tLight) {
        isect.normal = normalForSphere(isect.position, light, lightSize);
        isect.isLight = true;
    }
    return isect;
}vec3 cosineWeightedDirection(float seed, vec3 normal) {
    // Simple cosine-weighted random direction
    float u = random(vec3(12.9898, 78.233, 151.7182), seed);
    float v = random(vec3(63.7264, 10.873, 623.6736), seed);
    float r = sqrt(u);
    float angle = 6.28318530718 * v;
    vec3 sdir, tdir;
    if (abs(normal.x) < .5) {
        sdir = cross(normal, vec3(1,0,0));
    } else {
        sdir = cross(normal, vec3(0,1,0));
    }
    tdir = cross(normal, sdir);
    return normalize(r*cos(angle)*sdir + r*sin(angle)*tdir + sqrt(1.-u)*normal);
}

vec3 uniformSpherePos(vec3 origin, float seed, vec3 center, float radius) {
    float u = random(vec3(12.9898, 78.233, 151.7182), seed);
    float v = random(vec3(63.7264, 10.873, 623.6736), seed);
    float theta = 2.0 * pi * u;
    float phi = acos(2.0 * v - 1.0);
    vec3 lightPoint = center + radius * vec3(cos(theta) * sin(phi), sin(theta) * sin(phi), cos(phi));
    return lightPoint;
}

vec3 uniformSphereDirection(vec3 origin, float seed, vec3 center, float radius) {
    vec3 lightPoint = uniformSpherePos(origin, seed, center, radius);
    return normalize(lightPoint - origin);
}

float pdfCosineWeighted(vec3 direction, vec3 normal) {
    float cosTheta = dot(direction, normal);
    if (cosTheta <= 0.0) return epsilon;
    return cosTheta / pi;
}

float pdfUniformSphere(vec3 direction, vec3 origin) {
    Isect isect = intersect(direction, origin);
    if (isect.isLight) {
        vec3 fromLightDir = -direction;
        float dist2 = dot(fromLightDir, fromLightDir);
        fromLightDir = normalize(fromLightDir);
        vec3 lightNormal = normalize(isect.position - light);
        float cosAtLight = max(0.0, dot(lightNormal, fromLightDir));
        if (cosAtLight < epsilon || dist2 < epsilon) return epsilon;
        float surfaceArea = 4.0 * pi * lightSize * lightSize;
        // Conversion factor from area to solid angle pdf is cos(theta)/dist2 and you divide by conversion factor
        float pArea = (1.0 / surfaceArea) * (dist2 / cosAtLight);
        return pArea;
    }
    return epsilon;
}

float shadow(vec3 origin, vec3 ray, vec3 sphereCenter, float sphereRadius) {
    float t = intersectSphere(origin, ray, sphereCenter, sphereRadius);
    if (t < 1.0) return 0.0;
    return 1.0;
}

float balanceHeuristic(float pdf_a, float nb_pdf_a, float pdf_b, float nb_pdf_b) {
    return pdf_a / (nb_pdf_a * pdf_a + nb_pdf_b * pdf_b + epsilon);
}
float evaluate_target_function_at_center(vec3 light_sample, Isect isect, vec3 brdf) {
    vec3 sample_direction = normalize(light_sample - isect.position);
    Isect light_isect = intersect(sample_direction, isect.position);
    float visibility = light_isect.isLight ? 1.0 : 0.0;
    float ndotr = dot(isect.normal, sample_direction);
    vec3 contribution = brdf * abs(ndotr) * visibility;
    return dot(contribution, vec3(0.3086, 0.6094, 0.0820));
}
struct ReSTIR_Reservoir {
    vec3 Y;      // light direction or position
    float W_Y;   // selected sample weight
    float p_hat;
    float w_sum; // total weight of all candidates
    float c;    //sample count
    float t; //geometry info
};

ReSTIR_Reservoir initializeReservoir() {
    ReSTIR_Reservoir r;
    r.Y = vec3(0.0);
    r.W_Y = 0.0;
    r.w_sum = 0.0;

    return r;
}

ReSTIR_Reservoir unpackReservoir(vec4 data1, vec4 data2) {
    ReSTIR_Reservoir r;
    r.Y = data1.rgb;        // using .rgb for vec3
    r.p_hat = data1.a;
    r.W_Y = data2.r;
    r.w_sum = data2.g;
    r.t = data2.b;
    r.c = data2.a;
    return r;
}

vec4 packReservoir1(ReSTIR_Reservoir r) {
    return vec4(r.Y, r.p_hat);
}

vec4 packReservoir2(ReSTIR_Reservoir r) {
    return vec4(r.W_Y, r.w_sum, r.t, r.c); // zero pad unused values
}
ReSTIR_Reservoir sample_lights_ris(ReSTIR_Reservoir r_in, Isect isect, vec3 ray, int nb_bsdf, int nb_light, float seed) {
    ReSTIR_Reservoir r = r_in;
    int M = nb_bsdf + nb_light;
    vec3 nextOrigin = isect.position + isect.normal * epsilon;
    float baseSeed = hashValue(float(M) * 23.0 + 79.0) + seed;

    for (int candidate = 0; candidate < M; candidate++) {
        vec3 next_ray = ray;
        vec3 light_sample;
        float cBaseSeed = baseSeed * 17.51 + hashValue(float(candidate)) * 119.73;

        float reservoirWeight = 0.0;
        bool usedCosine = candidate < NB_BSDF;
        if (usedCosine) {
            next_ray = cosineWeightedDirection(cBaseSeed + 11.37, isect.normal);
            // is bsdf so need to check if ray ends at light
            Isect next_isect = intersect(next_ray, nextOrigin);
            if (!next_isect.isLight) {
                continue;
            }
            light_sample = next_isect.position;
        } else {
            light_sample = uniformSpherePos(isect.position, cBaseSeed + 23.57, light, lightSize);
            next_ray = normalize(light_sample - isect.position);
        }

        float pdfCosine = pdfCosineWeighted(next_ray, isect.normal);
        float pdfLight = pdfUniformSphere(next_ray, isect.position);

        float pdfA = usedCosine? pdfCosine : pdfLight;
        float pdfB = usedCosine? pdfLight : pdfCosine;
        float nbPdfA = float(usedCosine ? NB_BSDF : NB_LIGHT);
        float nbPdfB = float(usedCosine ? NB_LIGHT : NB_BSDF);
        float misWeight = balanceHeuristic(pdfA, nbPdfA, pdfB, nbPdfB);

        float pdfX = max(epsilon, usedCosine ? pdfCosine : pdfLight);

        vec3 brdf = isect.albedo / pi;
        float ndotr = dot(isect.normal, next_ray);
        float pHat = evaluate_target_function_at_center(light_sample, isect, brdf);

        if (ndotr <= epsilon || pHat <= epsilon || pdfX <= epsilon) {
            continue;
        }

        reservoirWeight = misWeight * pHat / pdfX;
        r.w_sum += reservoirWeight;
        float reservoirStrategy = random(vec3(1.0), cBaseSeed + 7.23);
        if (reservoirStrategy < reservoirWeight / r.w_sum) {
            r.p_hat = pHat;
            r.Y = light_sample;
            r.t = isect.t;
        }
    }

    if (r.w_sum > 0.0) {
        r.W_Y = r.w_sum / max(r.p_hat, epsilon);
    }
    r.c = 1.0;
    return r;
}

out vec4 fragColor;

vec4 calculateColor(vec3 origin, vec3 ray, vec3 light) {
    vec3 colorMask = vec3(1.0);
    vec3 accumulatedColor = vec3(0.0);
    vec3 directLight = vec3(0.0);

    float timeEntropy = hashValue(uTime);
    float seed = hashCoords(gl_FragCoord.xy + timeEntropy * vec2(1.0, -1.0));
    float total_dist = 0.0;

    float russian_roulette_prob = 1.0;
    for (int bounce = 0; bounce < 1; bounce++) {
        float roulette = random(vec3(36.7539, 50.3658, 306.2759), dot(gl_FragCoord.xy, vec2(12.9898, 78.233)) + uTime * 17.13 + float(bounce) * 91.71);
        if (roulette >= russian_roulette_prob) {
            break;
        }
        colorMask /= russian_roulette_prob;
        Isect isect = intersect(ray, origin);
        if (isect.t == infinity) {
            break;
        }

        vec3 nextOrigin = isect.position + isect.normal * epsilon;
        float baseSeed = hashValue(float(bounce) * 51.19 + 79.0) + seed;

        ReSTIR_Reservoir r = initializeReservoir();
        r = sample_lights_ris(r, isect, ray, NB_BSDF, NB_LIGHT, baseSeed);

        if (isect.isLight && bounce == 0) {
            accumulatedColor += lightIntensity;
        }

        if (r.w_sum > 0.0) {
            vec3 brdf = isect.albedo / pi;
            vec3 sample_direction = normalize(r.Y - isect.position);
            float ndotr = dot(isect.normal, sample_direction);
            directLight = lightIntensity * brdf * abs(ndotr) * r.W_Y;
            accumulatedColor += colorMask * directLight;
        }

        vec3 nextRay = cosineWeightedDirection(baseSeed, isect.normal);
        float pdfCosine = pdfCosineWeighted(nextRay, isect.normal);
        float ndotr = dot(isect.normal, nextRay);
        if (ndotr <= 0.0 || pdfCosine <= epsilon) break;
        vec3 brdf = isect.albedo / pi;
        colorMask *= brdf * ndotr / pdfCosine;

        // Russian Roulette Termination
        float throughput_max_element = max(max(colorMask.x, colorMask.y), colorMask.z);

        russian_roulette_prob = min(throughput_max_element, 1.0);

        origin = nextOrigin;
        ray = nextRay;
    }

    return vec4(accumulatedColor, 1.0);
}

void main() {

    // Avoid using 'texture' as a variable name
    vec3 texColor = texture(uTexture, gl_FragCoord.xy / uRes).rgb;

    vec4 color = calculateColor(uEye, initialRay, light);
    // vec3 color = mix(calculateColor(uEye, initialRay, light), texColor, uTextureWeight);
    fragColor = color;
}
`;